// SPDX-License-Identifier: Apache-2.0
//                                  Apache License
//                            Version 2.0, January 2004
//                         http://www.apache.org/licenses/

//    TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

//    1. Definitions.

//       "License" shall mean the terms and conditions for use, reproduction,
//       and distribution as defined by Sections 1 through 9 of this document.

//       "Licensor" shall mean the copyright owner or entity authorized by
//       the copyright owner that is granting the License.

//       "Legal Entity" shall mean the union of the acting entity and all
//       other entities that control, are controlled by, or are under common
//       control with that entity. For the purposes of this definition,
//       "control" means (i) the power, direct or indirect, to cause the
//       direction or management of such entity, whether by contract or
//       otherwise, or (ii) ownership of fifty percent (50%) or more of the
//       outstanding shares, or (iii) beneficial ownership of such entity.

//       "You" (or "Your") shall mean an individual or Legal Entity
//       exercising permissions granted by this License.

//       "Source" form shall mean the preferred form for making modifications,
//       including but not limited to software source code, documentation
//       source, and configuration files.

//       "Object" form shall mean any form resulting from mechanical
//       transformation or translation of a Source form, including but
//       not limited to compiled object code, generated documentation,
//       and conversions to other media types.

//       "Work" shall mean the work of authorship, whether in Source or
//       Object form, made available under the License, as indicated by a
//       copyright notice that is included in or attached to the work
//       (an example is provided in the Appendix below).

//       "Derivative Works" shall mean any work, whether in Source or Object
//       form, that is based on (or derived from) the Work and for which the
//       editorial revisions, annotations, elaborations, or other modifications
//       represent, as a whole, an original work of authorship. For the purposes
//       of this License, Derivative Works shall not include works that remain
//       separable from, or merely link (or bind by name) to the interfaces of,
//       the Work and Derivative Works thereof.

//       "Contribution" shall mean any work of authorship, including
//       the original version of the Work and any modifications or additions
//       to that Work or Derivative Works thereof, that is intentionally
//       submitted to Licensor for inclusion in the Work by the copyright owner
//       or by an individual or Legal Entity authorized to submit on behalf of
//       the copyright owner. For the purposes of this definition, "submitted"
//       means any form of electronic, verbal, or written communication sent
//       to the Licensor or its representatives, including but not limited to
//       communication on electronic mailing lists, source code control systems,
//       and issue tracking systems that are managed by, or on behalf of, the
//       Licensor for the purpose of discussing and improving the Work, but
//       excluding communication that is conspicuously marked or otherwise
//       designated in writing by the copyright owner as "Not a Contribution."

//       "Contributor" shall mean Licensor and any individual or Legal Entity
//       on behalf of whom a Contribution has been received by Licensor and
//       subsequently incorporated within the Work.

//    2. Grant of Copyright License. Subject to the terms and conditions of
//       this License, each Contributor hereby grants to You a perpetual,
//       worldwide, non-exclusive, no-charge, royalty-free, irrevocable
//       copyright license to reproduce, prepare Derivative Works of,
//       publicly display, publicly perform, sublicense, and distribute the
//       Work and such Derivative Works in Source or Object form.

//    3. Grant of Patent License. Subject to the terms and conditions of
//       this License, each Contributor hereby grants to You a perpetual,
//       worldwide, non-exclusive, no-charge, royalty-free, irrevocable
//       (except as stated in this section) patent license to make, have made,
//       use, offer to sell, sell, import, and otherwise transfer the Work,
//       where such license applies only to those patent claims licensable
//       by such Contributor that are necessarily infringed by their
//       Contribution(s) alone or by combination of their Contribution(s)
//       with the Work to which such Contribution(s) was submitted. If You
//       institute patent litigation against any entity (including a
//       cross-claim or counterclaim in a lawsuit) alleging that the Work
//       or a Contribution incorporated within the Work constitutes direct
//       or contributory patent infringement, then any patent licenses
//       granted to You under this License for that Work shall terminate
//       as of the date such litigation is filed.

//    4. Redistribution. You may reproduce and distribute copies of the
//       Work or Derivative Works thereof in any medium, with or without
//       modifications, and in Source or Object form, provided that You
//       meet the following conditions:

//       (a) You must give any other recipients of the Work or
//           Derivative Works a copy of this License; and

//       (b) You must cause any modified files to carry prominent notices
//           stating that You changed the files; and

//       (c) You must retain, in the Source form of any Derivative Works
//           that You distribute, all copyright, patent, trademark, and
//           attribution notices from the Source form of the Work,
//           excluding those notices that do not pertain to any part of
//           the Derivative Works; and

//       (d) If the Work includes a "NOTICE" text file as part of its
//           distribution, then any Derivative Works that You distribute must
//           include a readable copy of the attribution notices contained
//           within such NOTICE file, excluding those notices that do not
//           pertain to any part of the Derivative Works, in at least one
//           of the following places: within a NOTICE text file distributed
//           as part of the Derivative Works; within the Source form or
//           documentation, if provided along with the Derivative Works; or,
//           within a display generated by the Derivative Works, if and
//           wherever such third-party notices normally appear. The contents
//           of the NOTICE file are for informational purposes only and
//           do not modify the License. You may add Your own attribution
//           notices within Derivative Works that You distribute, alongside
//           or as an addendum to the NOTICE text from the Work, provided
//           that such additional attribution notices cannot be construed
//           as modifying the License.

//       You may add Your own copyright statement to Your modifications and
//       may provide additional or different license terms and conditions
//       for use, reproduction, or distribution of Your modifications, or
//       for any such Derivative Works as a whole, provided Your use,
//       reproduction, and distribution of the Work otherwise complies with
//       the conditions stated in this License.

//    5. Submission of Contributions. Unless You explicitly state otherwise,
//       any Contribution intentionally submitted for inclusion in the Work
//       by You to the Licensor shall be under the terms and conditions of
//       this License, without any additional terms or conditions.
//       Notwithstanding the above, nothing herein shall supersede or modify
//       the terms of any separate license agreement you may have executed
//       with Licensor regarding such Contributions.

//    6. Trademarks. This License does not grant permission to use the trade
//       names, trademarks, service marks, or product names of the Licensor,
//       except as required for reasonable and customary use in describing the
//       origin of the Work and reproducing the content of the NOTICE file.

//    7. Disclaimer of Warranty. Unless required by applicable law or
//       agreed to in writing, Licensor provides the Work (and each
//       Contributor provides its Contributions) on an "AS IS" BASIS,
//       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
//       implied, including, without limitation, any warranties or conditions
//       of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
//       PARTICULAR PURPOSE. You are solely responsible for determining the
//       appropriateness of using or redistributing the Work and assume any
//       risks associated with Your exercise of permissions under this License.

//    8. Limitation of Liability. In no event and under no legal theory,
//       whether in tort (including negligence), contract, or otherwise,
//       unless required by applicable law (such as deliberate and grossly
//       negligent acts) or agreed to in writing, shall any Contributor be
//       liable to You for damages, including any direct, indirect, special,
//       incidental, or consequential damages of any character arising as a
//       result of this License or out of the use or inability to use the
//       Work (including but not limited to damages for loss of goodwill,
//       work stoppage, computer failure or malfunction, or any and all
//       other commercial damages or losses), even if such Contributor
//       has been advised of the possibility of such damages.

//    9. Accepting Warranty or Additional Liability. While redistributing
//       the Work or Derivative Works thereof, You may choose to offer,
//       and charge a fee for, acceptance of support, warranty, indemnity,
//       or other liability obligations and/or rights consistent with this
//       License. However, in accepting such obligations, You may act only
//       on Your own behalf and on Your sole responsibility, not on behalf
//       of any other Contributor, and only if You agree to indemnify,
//       defend, and hold each Contributor harmless for any liability
//       incurred by, or claims asserted against, such Contributor by reason
//       of your accepting any such warranty or additional liability.

//    END OF TERMS AND CONDITIONS

//    Copyright (C) 2020 Cartesi Pte. Ltd.

//    Licensed under the Apache License, Version 2.0 (the "License");
//    you may not use this file except in compliance with the License.
//    You may obtain a copy of the License at

//        http://www.apache.org/licenses/LICENSE-2.0

//    Unless required by applicable law or agreed to in writing, software
//    distributed under the License is distributed on an "AS IS" BASIS,
//    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//    See the License for the specific language governing permissions and
//    limitations under the License.

/// @title CartesiCompute
/// @author Stephen Chen
pragma solidity ^0.7.0;
pragma experimental ABIEncoderV2;

// #if BUILD_TEST
import "./test/TestMerkle.sol";
// #else
import "@cartesi/util/contracts/Merkle.sol";
// #endif
import "@cartesi/util/contracts/Decorated.sol";
import "@cartesi/util/contracts/InstantiatorImpl.sol";
import "@cartesi/arbitration/contracts/VGInterface.sol";
import "./CartesiComputeInterface.sol";

contract CartesiCompute is
    InstantiatorImpl,
    Decorated,
    CartesiComputeInterface
{
    address machine; // machine which will run the challenge
    VGInterface vg;

    struct CartesiComputeCtx {
        address owner; // the one who has power to shutdown the instance
        uint256 finalTime; // max number of machine cycle to run
        uint64 outputPosition; // memory position of machine output
        uint8 outputLog2Size; // log2 size of the output drive in the unit of bytes
        uint256 roundDuration; // time interval to interact with this contract
        uint256 timeOfLastMove; // last time someone made a move with deadline
        uint256 vgInstance;
        bytes32 templateHash; // pristine hash of machine
        bytes32 initialHash; // initial hash with all drives mounted
        bytes32 claimedFinalHash; // claimed final hash of the machine
        bytes claimedOutput; // claimed final machine output
        address[] partiesArray; // user can challenge claimer's output
        address[] confirmedParties; // parties that have confirmed the current claim
        uint64 claimer; // responsible for claiming the machine output
        uint64 currentChallenger; // it tracks who did the last challenge
        uint64 votesCounter; // helps manage end state
        mapping(address => Party) parties; // control structure for challengers
        State currentState;
        bytes32[] driveHash; // root hash of the drives
        Drive[] inputDrives;
    }

    mapping(uint256 => CartesiComputeCtx) internal instance;

    // These are the possible states and transitions of the contract.

    // +---+
    // |   |
    // +---+
    //   |
    //   | instantiate
    //   v
    // +--------------+   abortByDeadline    +-----------------------+
    // | WaitingClaim |--------------------->| ClaimerMissedDeadline |
    // +--------------+                      +-----------------------+
    //   |
    //   | submitClaim
    //   v
    // +-----------------------------+             +-----------------+
    // | WaitingConfirmationDeadline |------------>| ConsensusResult |
    // +----------------------------+   deadline  +-----------------+
    //   |
    //   |
    //   | challenge
    //   v
    // +------------------------+    winByVG     +------------+  if there are challengers
    // | WaitingChallengeResult |--------------->| ClaimerWon |-----------------------> WaitingConfirmationDeadline
    // +-----------------------+                +------------+    left; go back to
    //   |
    //   |
    //   |                  winByVG        +---------------+  if there are challengers
    //   +-------------------------------->| ChallengerWon |------------------------> WaitingClaim
    //                                     +---------------+  left; go back to
    //

    event CartesiComputeCreated(uint256 _index);
    event ClaimSubmitted(uint256 _index, bytes32 _claimedFinalHash);
    event ChallengeStarted(uint256 _index);
    event CartesiComputeFinished(uint256 _index, bytes32 _state);
    event Confirmed(uint256 _index, address _confirmParty);

    constructor(
        address _vgAddress,
        address _machineAddress
    ) {
        machine = _machineAddress;
        vg = VGInterface(_vgAddress);
    }

    /// @notice Instantiate a Cartesi Compute SDK instance.
    /// @param _finalTime max cycle of the machine for that computation
    /// @param _templateHash hash of the machine with all drives empty
    /// @param _outputPosition position of the output drive
    /// @param _roundDuration duration of the round (security param)
    /// @param _inputDrives an array of drive which assemble the machine
    /// @return uint256, Cartesi Compute index
    function instantiate(
        uint256 _finalTime,
        bytes32 _templateHash,
        uint64 _outputPosition,
        uint8 _outputLog2Size,
        uint256 _roundDuration,
        address[] memory parties,
        Drive[] memory _inputDrives
    ) public override returns (uint256) {
        require(_roundDuration >= 50, "round duration must be 50+ seconds");
        CartesiComputeCtx storage i = instance[currentIndex];

        for (uint64 j = 0; j < parties.length; j++) {
            require(
                i.parties[parties[j]].isParty == false,
                "Party addresses must be unique"
            );
            i.parties[parties[j]].isParty = true;
            i.parties[parties[j]].arrayIdx = j;
            i.partiesArray.push(parties[j]);
        }

        uint256 drivesLength = _inputDrives.length;
        i.driveHash = new bytes32[](drivesLength);

        for (uint256 j = 0; j < drivesLength; j++) {
            Drive memory drive = _inputDrives[j];

            if (drive.directDrive) {
                // direct drive
                require(
                    drive.driveLog2Size >= 3,
                    "directValue has to be at least one word"
                );

                // direct drive provided at instantiation
                require(
                    drive.directValue.length <= 2 ** drive.driveLog2Size,
                    "Input bytes length exceeds claimed log2 size"
                );

                // pad zero to the directValue if it's not exact power of 2
                bytes memory paddedDirectValue = drive.directValue;
                if (drive.directValue.length < 2 ** drive.driveLog2Size) {
                    paddedDirectValue = abi.encodePacked(
                        drive.directValue,
                        new bytes(
                            2 ** drive.driveLog2Size - drive.directValue.length
                        )
                    );
                }

                bytes32[] memory data = getWordHashesFromBytes(
                    paddedDirectValue
                );
                i.driveHash[j] = Merkle.calculateRootFromPowerOfTwo(data);
            } else {
                // large drive provided with logger hash at instantiation
                i.driveHash[j] = drive.driveRootHash;
            }
            i.inputDrives.push(
                Drive(
                    drive.position,
                    drive.driveLog2Size,
                    drive.directValue,
                    drive.driveRootHash,
                    drive.directDrive
                )
            );
        }

        require(
            _outputLog2Size >= 3,
            "output drive has to be at least one word"
        );

        i.owner = msg.sender;
        // i.claimer = 0; parties[0]; // first on the list is selected to be claimer
        i.votesCounter = 1; // first vote is always a submitClaim, so we count it once here
        i.finalTime = _finalTime;
        i.templateHash = _templateHash;
        i.initialHash = _templateHash;
        i.outputPosition = _outputPosition;
        i.outputLog2Size = _outputLog2Size;
        i.roundDuration = _roundDuration;
        i.timeOfLastMove = block.timestamp;
        i.currentState = State.WaitingClaim;

        emit CartesiComputeCreated(currentIndex);
        active[currentIndex] = true;
        return currentIndex++;
    }

    /// @notice Challenger disputes the claim, starting a verification game.
    /// @param _index index of Cartesi Compute instance which challenger is starting the VG.
    function challenge(
        uint256 _index
    )
        public
        onlyActive(_index)
        onlyByParty(_index)
        onlyNoVotes(_index)
        increasesNonce(_index)
    {
        CartesiComputeCtx storage i = instance[_index];
        require(
            i.currentState == State.WaitingConfirmationDeadline,
            "State should be WaitingConfirmationDeadline"
        );

        i.vgInstance = vg.instantiate(
            msg.sender, // challenger
            i.partiesArray[i.claimer],
            i.roundDuration,
            machine,
            i.initialHash,
            i.claimedFinalHash,
            i.finalTime
        );
        i.currentState = State.WaitingChallengeResult;
        i.parties[msg.sender].hasVoted = true;
        i.currentChallenger = i.parties[msg.sender].arrayIdx;
        i.votesCounter++;
        i.timeOfLastMove = block.timestamp;

        // @dev should we update timeOfLastMove over here too?
        emit ChallengeStarted(_index);
    }

    /// @notice Party confirms the claim
    /// @param _index index of Cartesi Compute instance which claimer being confirmed
    function confirm(
        uint256 _index
    )
        public
        onlyActive(_index)
        onlyByParty(_index)
        onlyNoVotes(_index)
        increasesNonce(_index)
    {
        CartesiComputeCtx storage i = instance[_index];
        require(
            i.currentState == State.WaitingConfirmationDeadline,
            "State should be WaitingConfirmationDeadline"
        );

        // record parties have confirmed current claim
        i.confirmedParties.push(msg.sender);
        i.parties[msg.sender].hasVoted = true;
        i.votesCounter++;
        // i.timeOfLastMove = block.timestamp;

        emit Confirmed(_index, msg.sender);

        if (i.votesCounter == i.partiesArray.length) {
            i.currentState = State.ConsensusResult;
            emit CartesiComputeFinished(_index, getCurrentState(_index));
        }

        return;
    }

    /// @notice Claimer claims the machine final hash and also validate the drives and initial hash of the machine.
    /// @param _claimedFinalHash is the final hash of the machine
    /// @param _drivesSiblings is an array of siblings of each drive (see below example)
    /// @param _output is the bytes32 value of the output position
    /// @param _outputSiblings is the siblings of the output drive
    /// @dev Example: consider 3 drives, the first drive's siblings should be a pristine machine.
    ///      The second drive's siblings should be the machine with drive 1 mounted.
    ///      The third drive's siblings should be the machine with drive 2 mounted.
    function submitClaim(
        uint256 _index,
        bytes32 _claimedFinalHash,
        bytes32[][] memory _drivesSiblings,
        bytes memory _output,
        bytes32[] memory _outputSiblings
    ) public onlyActive(_index) onlyByClaimer(_index) increasesNonce(_index) {
        CartesiComputeCtx storage i = instance[_index];

        require(
            i.currentState == State.WaitingClaim,
            "State must be WaitingClaim"
        );
        require(
            i.inputDrives.length == _drivesSiblings.length,
            "Claimed drive number should match claimed siblings number"
        );
        require(
            _output.length == 2 ** i.outputLog2Size,
            "Output length doesn't match output log2 size"
        );

        bytes32[] memory data = getWordHashesFromBytes(_output);
        require(
            Merkle.getRootWithDrive(
                i.outputPosition,
                i.outputLog2Size,
                Merkle.calculateRootFromPowerOfTwo(data),
                _outputSiblings
            ) == _claimedFinalHash,
            "Output not in final hash"
        );

        uint256 drivesLength = i.inputDrives.length;
        for (uint256 j = 0; j < drivesLength; j++) {
            bytes32[] memory driveSiblings = _drivesSiblings[j];
            require(
                Merkle.getRootWithDrive(
                    i.inputDrives[j].position,
                    i.inputDrives[j].driveLog2Size,
                    Merkle.getPristineHash(
                        uint8(i.inputDrives[j].driveLog2Size)
                    ),
                    driveSiblings
                ) == i.initialHash,
                "Drive siblings must be compatible with previous initial hash for empty drive"
            );
            i.initialHash = Merkle.getRootWithDrive(
                i.inputDrives[j].position,
                i.inputDrives[j].driveLog2Size,
                i.driveHash[j],
                driveSiblings
            );
        }

        i.claimedFinalHash = _claimedFinalHash;
        i.currentState = State.WaitingConfirmationDeadline;
        i.claimedOutput = _output;
        i.parties[i.partiesArray[i.claimer]].hasVoted = true;
        i.timeOfLastMove = block.timestamp;

        emit ClaimSubmitted(_index, _claimedFinalHash);
    }

    /// @notice Is the given user concern about this instance.
    function isConcerned(
        uint256 _index,
        address _user
    ) public view override onlyInstantiated(_index) returns (bool) {
        CartesiComputeCtx storage i = instance[_index];
        return i.parties[_user].isParty;
    }

    function getPartyState(
        uint256 _index,
        address _p
    )
        public
        view
        onlyInstantiated(_index)
        returns (bool isParty, bool hasVoted, bool hasCheated)
    {
        Party storage party = instance[_index].parties[_p];
        isParty = party.isParty;
        hasVoted = party.hasVoted;
        hasCheated = party.hasCheated;
    }

    /// @notice Get state of the instance concerning given user.
    function getState(
        uint256 _index,
        address _user
    )
        public
        view
        onlyInstantiated(_index)
        returns (
            uint256[] memory,
            address[] memory,
            bytes32[] memory,
            bytes memory,
            Drive[] memory,
            Party memory user
        )
    {
        CartesiComputeCtx storage i = instance[_index];

        user = i.parties[_user];

        uint256[] memory uintValues = new uint256[](4);
        uintValues[0] = i.finalTime;
        uintValues[1] = i.timeOfLastMove + getMaxStateDuration(_index);
        uintValues[2] = i.outputPosition;
        uintValues[3] = i.outputLog2Size;

        address[] memory addressValues = new address[](2);
        if (i.currentChallenger != 0)
            addressValues[0] = i.partiesArray[i.currentChallenger];
        addressValues[1] = i.partiesArray[i.claimer];

        bytes32[] memory bytes32Values = new bytes32[](4);
        bytes32Values[0] = i.templateHash;
        bytes32Values[1] = i.initialHash;
        bytes32Values[2] = i.claimedFinalHash;
        bytes32Values[3] = getCurrentState(_index);

        return (
            uintValues,
            addressValues,
            bytes32Values,
            i.claimedOutput,
            i.inputDrives,
            user
        );
    }

    function getCurrentState(
        uint256 _index
    ) public view onlyInstantiated(_index) returns (bytes32) {
        State currentState = instance[_index].currentState;
        if (currentState == State.ClaimerMissedDeadline) {
            return "ClaimerMissedDeadline";
        }
        if (currentState == State.WaitingClaim) {
            return "WaitingClaim";
        }
        if (currentState == State.WaitingConfirmationDeadline) {
            return "WaitingConfirmationDeadline";
        }
        if (currentState == State.WaitingChallengeResult) {
            return "WaitingChallengeResult";
        }
        if (currentState == State.ConsensusResult) {
            return "ConsensusResult";
        }
        if (currentState == State.ChallengerWon) {
            return "ChallengerWon";
        }
        if (currentState == State.ClaimerWon) {
            return "ClaimerWon";
        }

        revert("Unrecognized state");
    }

    /// @notice Get sub-instances of the instance.
    function getSubInstances(
        uint256 _index,
        address
    )
        public
        view
        override
        onlyInstantiated(_index)
        returns (address[] memory _addresses, uint256[] memory _indices)
    {
        address[] memory a;
        uint256[] memory i;

        if (instance[_index].currentState == State.WaitingChallengeResult) {
            a = new address[](1);
            i = new uint256[](1);
            a[0] = address(vg);
            i[0] = instance[_index].vgInstance;
        } else {
            a = new address[](0);
            i = new uint256[](0);
        }
        return (a, i);
    }

    /// @notice In case one of the parties wins the verification game,
    ///         then he or she can call this function to claim victory in
    ///         this contract as well.
    /// @param _index index of Cartesi Compute instance to win
    function winByVG(
        uint256 _index
    ) public onlyActive(_index) increasesNonce(_index) {
        CartesiComputeCtx storage i = instance[_index];
        require(
            i.currentState == State.WaitingChallengeResult,
            "State != WaitingChallengeResult, cannot winByVG"
        );
        i.timeOfLastMove = block.timestamp;
        uint256 vgIndex = i.vgInstance;

        if (vg.stateIsFinishedChallengerWon(vgIndex)) {
            i.parties[i.partiesArray[i.claimer]].hasCheated = true;
            // all parties have confirmed cheated claimer should be reset
            // this is a protection to avoid claimer losing dispute on purpose
            for (uint256 p = 0; p < i.confirmedParties.length; p++) {
                i.parties[i.confirmedParties[p]].hasVoted = false;
            }
            i.votesCounter -= uint64(i.confirmedParties.length);
            // reset confirmed parties
            delete i.confirmedParties;

            if (i.votesCounter == i.partiesArray.length) {
                i.currentState = State.ChallengerWon;
                emit CartesiComputeFinished(_index, getCurrentState(_index));
                return;
            }
            i.currentState = State.WaitingClaim;
            i.claimer = i.currentChallenger;
            i.currentChallenger = 0;
            return;
        }

        if (vg.stateIsFinishedClaimerWon(vgIndex)) {
            i.parties[i.partiesArray[i.currentChallenger]].hasCheated = true;
            if (i.votesCounter == i.partiesArray.length) {
                i.currentState = State.ClaimerWon;
                emit CartesiComputeFinished(_index, getCurrentState(_index));
                return;
            }
            i.currentState = State.WaitingConfirmationDeadline;
            i.currentChallenger = 0;
            return;
        }
        require(false, "VG state not final");
    }

    /// @notice Deactivate a Cartesi Compute SDK instance.
    /// @param _index index of Cartesi Compute instance to deactivate
    function destruct(
        uint256 _index
    ) public override onlyActive(_index) onlyBy(instance[_index].owner) {
        CartesiComputeCtx storage i = instance[_index];
        require(
                i.currentState == State.ClaimerMissedDeadline ||
                i.currentState == State.ConsensusResult ||
                i.currentState == State.ChallengerWon ||
                i.currentState == State.ClaimerWon,
            "Cannot destruct instance at current state"
        );

        delete i.driveHash;
        delete i.inputDrives;
        deactivate(_index);
    }

    /// @notice Abort the instance by missing deadline.
    /// @param _index index of Cartesi Compute instance to abort
    function abortByDeadline(uint256 _index) public onlyActive(_index) {
        CartesiComputeCtx storage i = instance[_index];
        bool afterDeadline = block.timestamp >
            (i.timeOfLastMove + getMaxStateDuration(_index));

        require(afterDeadline, "Deadline not over");

        if (i.currentState == State.WaitingClaim) {
            i.currentState = State.ClaimerMissedDeadline;
            emit CartesiComputeFinished(_index, getCurrentState(_index));
            return;
        }
        if (i.currentState == State.WaitingConfirmationDeadline) {
            i.currentState = State.ConsensusResult;
            emit CartesiComputeFinished(_index, getCurrentState(_index));
            return;
        }

        revert("Cannot abort current state");
    }

    /// @notice Get result of a finished instance.
    /// @param _index index of Cartesi Compute instance to get result
    /// @return bool, indicates the result is ready
    /// @return bool, indicates the sdk is still running
    /// @return address, the user to blame for the abnormal stop of the sdk
    /// @return bytes, the result of the sdk if available
    function getResult(
        uint256 _index
    )
        public
        view
        override
        onlyInstantiated(_index)
        returns (bool, bool, address, bytes memory)
    {
        CartesiComputeCtx storage i = instance[_index];
        if (i.currentState == State.ConsensusResult) {
            return (true, false, address(0), i.claimedOutput);
        }
        if (
            i.currentState == State.WaitingClaim ||
            i.currentState == State.WaitingConfirmationDeadline ||
            i.currentState == State.WaitingChallengeResult
        ) {
            return (false, true, address(0), "");
        }

        if (
            i.currentState == State.ClaimerMissedDeadline ||
            i.currentState == State.ChallengerWon
        ) {
            return (false, false, i.partiesArray[i.claimer], "");
        }
        if (i.currentState == State.ClaimerWon) {
            return (false, false, i.partiesArray[i.currentChallenger], "");
        }

        revert("Unrecognized state");
    }

    /// @notice Convert bytes32 into bytes8[] and calculate the hashes of them
    function getWordHashesFromBytes32(
        bytes32 _value
    ) private pure returns (bytes32[] memory) {
        bytes32[] memory data = new bytes32[](4);
        for (uint256 i = 0; i < 4; i++) {
            bytes8 dataBytes8 = bytes8(
                (_value << (i * 64)) &
                    0xffffffffffffffff000000000000000000000000000000000000000000000000
            );
            data[i] = keccak256(abi.encodePacked(dataBytes8));
        }
        return data;
    }

    /// @notice Convert bytes into bytes8[] and calculate the hashes of them
    function getWordHashesFromBytes(
        bytes memory _value
    ) private pure returns (bytes32[] memory) {
        uint256 hashesLength = _value.length / 8;
        bytes32[] memory data = new bytes32[](hashesLength);
        for (uint256 i = 0; i < hashesLength; i++) {
            bytes8 dataBytes8;
            for (uint256 j = 0; j < 8; j++) {
                bytes8 tempBytes8 = _value[i * 8 + j];
                tempBytes8 = tempBytes8 >> (j * 8);
                dataBytes8 = dataBytes8 | tempBytes8;
            }
            data[i] = keccak256(abi.encodePacked(dataBytes8));
        }
        return data;
    }

    /// @notice Get the worst case scenario duration for a specific state
    function getMaxStateDuration(
        uint256 _index
    ) private view returns (uint256) {
        // TODO: make sure maxDuration calculations are reasonable
        uint256 partitionSize = 1;
        uint256 picoSecondsToRunInsn = 500; // 500 pico seconds to run a instruction
        uint256 timeToStartMachine = 40; // 40 seconds to start the machine for the first time

        if (instance[_index].currentState == State.WaitingClaim) {
            // time to run entire machine + time to react
            return
                timeToStartMachine +
                ((instance[_index].finalTime * picoSecondsToRunInsn) / 1e12) +
                instance[_index].roundDuration;
        }

        if (
            instance[_index].currentState == State.WaitingConfirmationDeadline
        ) {
            // time to run entire machine + time to react
            return
                timeToStartMachine +
                ((instance[_index].finalTime * picoSecondsToRunInsn) / 1e12) +
                instance[_index].roundDuration;
        }

        if (instance[_index].currentState == State.WaitingChallengeResult) {
            // time to run a verification game + time to react
            return
                vg.getMaxInstanceDuration(
                    instance[_index].roundDuration,
                    timeToStartMachine,
                    partitionSize,
                    instance[_index].finalTime,
                    picoSecondsToRunInsn
                ) + instance[_index].roundDuration;
        }

        if (
            instance[_index].currentState == State.ClaimerWon ||
            instance[_index].currentState == State.ChallengerWon ||
            instance[_index].currentState == State.ClaimerMissedDeadline ||
            instance[_index].currentState == State.ConsensusResult
        ) {
            return 0; // final state
        }
    }

    /// @notice checks whether or not it's a party to this instance
    modifier onlyByParty(uint256 _index) {
        CartesiComputeCtx storage i = instance[_index];
        require(i.parties[msg.sender].isParty, "Sender must be a party");
        _;
    }

    modifier onlyByClaimer(uint256 _index) {
        CartesiComputeCtx storage i = instance[_index];
        require(
            i.partiesArray[i.claimer] == msg.sender,
            "Sender must be a claimer"
        );
        _;
    }

    /// @notice checks whether or not a party has already voted
    modifier onlyNoVotes(uint256 _index) {
        CartesiComputeCtx storage i = instance[_index];
        require(!i.parties[msg.sender].hasVoted, "Sender has already voted");
        _;
    }
}
