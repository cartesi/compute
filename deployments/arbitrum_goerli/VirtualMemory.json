{
  "address": "0x2b37C920B9469e44938ABf6dDBD398D7b4329d16",
  "abi": [],
  "transactionHash": "0xccc6b60635427ab932001a5b34dca8427698f4ce53c06ba43b6a04ebd6b2869a",
  "receipt": {
    "to": null,
    "from": "0xD63A9d27E7A573e28889A363310443Cba076D546",
    "contractAddress": "0x2b37C920B9469e44938ABf6dDBD398D7b4329d16",
    "transactionIndex": 1,
    "gasUsed": "2376571",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x6d19ade7124c13df2ed154e73935915c78ad9a81b63d90f7869ab244d6848cd2",
    "transactionHash": "0xccc6b60635427ab932001a5b34dca8427698f4ce53c06ba43b6a04ebd6b2869a",
    "logs": [],
    "blockNumber": 310192,
    "cumulativeGasUsed": "2376571",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "metadata": "{\"compiler\":{\"version\":\"0.7.4+commit.3f05b770\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"author\":\"Felipe Argento\",\"kind\":\"dev\",\"methods\":{\"readVirtualMemory(MemoryInteractor,uint64,uint64)\":{\"params\":{\"vaddr\":\"is the words virtual address\",\"wordSize\":\"can be uint8, uint16, uint32 or uint64\"},\"returns\":{\"_0\":\"True if write was succesfull, false if not.\",\"_1\":\"Word with receiveing value.\"}},\"writeVirtualMemory(MemoryInteractor,uint64,uint64,uint64)\":{\"params\":{\"vaddr\":\"is the words virtual address\",\"val\":\"is the value to be written\",\"wordSize\":\"can be uint8, uint16, uint32 or uint64\"},\"returns\":{\"_0\":\"True if write was succesfull, false if not.\"}}},\"title\":\"Virtual Memory\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"readVirtualMemory(MemoryInteractor,uint64,uint64)\":{\"notice\":\"Read word to virtual memory\"},\"writeVirtualMemory(MemoryInteractor,uint64,uint64,uint64)\":{\"notice\":\"Writes word to virtual memory\"}},\"notice\":\"Defines Virtual Memory behaviour\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/VirtualMemory.sol\":\"VirtualMemory\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@cartesi/util/contracts/BitsManipulationLibrary.sol\":{\"content\":\"// Copyright 2020 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\n\\npragma solidity ^0.7.0;\\n\\n/// @title Bits Manipulation Library\\n/// @author Felipe Argento / Stephen Chen\\n/// @notice Implements bit manipulation helper functions\\nlibrary BitsManipulationLibrary {\\n\\n    /// @notice Sign extend a shorter signed value to the full int32\\n    /// @param number signed number to be extended\\n    /// @param wordSize number of bits of the signed number, ie, 8 for int8\\n    function int32SignExtension(int32 number, uint32 wordSize)\\n    public pure returns(int32)\\n    {\\n        uint32 uNumber = uint32(number);\\n        bool isNegative = ((uint64(1) << (wordSize - 1)) & uNumber) > 0;\\n        uint32 mask = ((uint32(2) ** wordSize) - 1);\\n\\n        if (isNegative) {\\n            uNumber = uNumber | ~mask;\\n        }\\n\\n        return int32(uNumber);\\n    }\\n\\n    /// @notice Sign extend a shorter signed value to the full uint64\\n    /// @param number signed number to be extended\\n    /// @param wordSize number of bits of the signed number, ie, 8 for int8\\n    function uint64SignExtension(uint64 number, uint64 wordSize)\\n    public pure returns(uint64)\\n    {\\n        uint64 uNumber = number;\\n        bool isNegative = ((uint64(1) << (wordSize - 1)) & uNumber) > 0;\\n        uint64 mask = ((uint64(2) ** wordSize) - 1);\\n\\n        if (isNegative) {\\n            uNumber = uNumber | ~mask;\\n        }\\n\\n        return uNumber;\\n    }\\n\\n    /// @notice Swap byte order of unsigned ints with 64 bytes\\n    /// @param num number to have bytes swapped\\n    function uint64SwapEndian(uint64 num) public pure returns(uint64) {\\n        uint64 output = ((num & 0x00000000000000ff) << 56)|\\n            ((num & 0x000000000000ff00) << 40)|\\n            ((num & 0x0000000000ff0000) << 24)|\\n            ((num & 0x00000000ff000000) << 8) |\\n            ((num & 0x000000ff00000000) >> 8) |\\n            ((num & 0x0000ff0000000000) >> 24)|\\n            ((num & 0x00ff000000000000) >> 40)|\\n            ((num & 0xff00000000000000) >> 56);\\n\\n        return output;\\n    }\\n\\n    /// @notice Swap byte order of unsigned ints with 32 bytes\\n    /// @param num number to have bytes swapped\\n    function uint32SwapEndian(uint32 num) public pure returns(uint32) {\\n        uint32 output = ((num >> 24) & 0xff) | ((num << 8) & 0xff0000) | ((num >> 8) & 0xff00) | ((num << 24) & 0xff000000);\\n        return output;\\n    }\\n}\\n\\n\",\"keccak256\":\"0x95b97e0ae364fb91a3fdcf8132e7b61c745c23dd4e5beb980f396c05a69bbd08\",\"license\":\"Apache-2.0\"},\"contracts/CLINT.sol\":{\"content\":\"// Copyright 2019 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\n\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"./MemoryInteractor.sol\\\";\\nimport \\\"./RiscVConstants.sol\\\";\\nimport \\\"./RealTimeClock.sol\\\";\\n\\n\\n/// @title CLINT\\n/// @author Felipe Argento\\n/// @notice Implements the Core Local Interruptor functionalities\\n/// @dev CLINT active addresses are 0x0200bff8(mtime) and 0x02004000(mtimecmp)\\n/// Reference: The Core of Cartesi, v1.02 - Section 3.2 - The Board\\nlibrary CLINT {\\n\\n    uint64 constant CLINT_MSIP0_ADDR = 0x02000000;\\n    uint64 constant CLINT_MTIMECMP_ADDR = 0x02004000;\\n    uint64 constant CLINT_MTIME_ADDR = 0x0200bff8;\\n\\n    /// @notice reads clint\\n    /// @param offset can be uint8, uint16, uint32 or uint64\\n    /// @param wordSize can be uint8, uint16, uint32 or uint64\\n    /// @return bool if read was successfull\\n    /// @return uint64 pval\\n    function clintRead(\\n        MemoryInteractor mi,\\n        uint64 offset,\\n        uint64 wordSize\\n    )\\n    public returns (bool, uint64)\\n    {\\n\\n        if (offset == CLINT_MSIP0_ADDR) {\\n            return clintReadMsip(mi, wordSize);\\n        } else if (offset == CLINT_MTIMECMP_ADDR) {\\n            return clintReadMtime(mi, wordSize);\\n        } else if (offset == CLINT_MTIME_ADDR) {\\n            return clintReadMtimecmp(mi, wordSize);\\n        } else {\\n            return (false, 0);\\n        }\\n    }\\n\\n    /// @notice write to clint\\n    /// @param mi Memory Interactor with which Step function is interacting.\\n    /// @param offset can be uint8, uint16, uint32 or uint64\\n    /// @param val to be written\\n    /// @param wordSize can be uint8, uint16, uint32 or uint64\\n    /// @return bool if write was successfull\\n    function clintWrite(\\n        MemoryInteractor mi,\\n        uint64 offset,\\n        uint64 val,\\n        uint64 wordSize)\\n    public returns (bool)\\n    {\\n        if (offset == CLINT_MSIP0_ADDR) {\\n            if (wordSize == 32) {\\n                if ((val & 1) != 0) {\\n                    mi.setMip(RiscVConstants.getMipMsipMask());\\n                } else {\\n                    mi.resetMip(RiscVConstants.getMipMsipMask());\\n                }\\n                return true;\\n            }\\n            return false;\\n        } else if (offset == CLINT_MTIMECMP_ADDR) {\\n            if (wordSize == 64) {\\n                mi.writeClintMtimecmp(val);\\n                mi.resetMip(RiscVConstants.getMipMsipMask());\\n                return true;\\n            }\\n            // partial mtimecmp is not supported\\n            return false;\\n        }\\n        return false;\\n    }\\n\\n    // internal functions\\n    function clintReadMsip(MemoryInteractor mi, uint64 wordSize)\\n    internal returns (bool, uint64)\\n    {\\n        if (wordSize == 32) {\\n            if ((mi.readMip() & RiscVConstants.getMipMsipMask()) == RiscVConstants.getMipMsipMask()) {\\n                return(true, 1);\\n            } else {\\n                return (true, 0);\\n            }\\n        }\\n        return (false, 0);\\n    }\\n\\n    function clintReadMtime(MemoryInteractor mi, uint64 wordSize)\\n    internal returns (bool, uint64)\\n    {\\n        if (wordSize == 64) {\\n            return (true, RealTimeClock.rtcCycleToTime(mi.readMcycle()));\\n        }\\n        return (false, 0);\\n    }\\n\\n    function clintReadMtimecmp(MemoryInteractor mi, uint64 wordSize)\\n    internal returns (bool, uint64)\\n    {\\n        if (wordSize == 64) {\\n            return (true, mi.readClintMtimecmp());\\n        }\\n        return (false, 0);\\n    }\\n\\n    // getters\\n    function getClintMtimecmp() public pure returns (uint64) {\\n        return CLINT_MTIMECMP_ADDR;\\n    }\\n}\\n\\n\\n\",\"keccak256\":\"0x89a1c4305fc05859156cbd73380aa63ce16a48aba24ce44d4b862b5f415d6362\",\"license\":\"Apache-2.0\"},\"contracts/Exceptions.sol\":{\"content\":\"// Copyright 2019 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\n\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"./MemoryInteractor.sol\\\";\\nimport \\\"./RiscVConstants.sol\\\";\\n\\n/// @title Exceptions\\n/// @author Felipe Argento\\n/// @notice Implements raise exception behavior and mcause getters\\nlibrary Exceptions {\\n\\n    /// @notice Raise an exception (or interrupt).\\n    /// @param mi Memory Interactor with which Step function is interacting.\\n    /// @param cause Exception (or interrupt) mcause (or scause).\\n    /// @param tval Associated tval.\\n    function raiseException(\\n        MemoryInteractor mi,\\n        uint64 cause,\\n        uint64 tval)\\n    public\\n    {\\n        // All traps are handled in machine-mode, by default. Mideleg or Medeleg provide\\n        // bits to indicate if the interruption/exception should be taken care of by\\n        // lower privilege levels.\\n        // Medeleg -> Machine Exception Delegation register\\n        // Mideleg -> Machine Interrupt Delegation register\\n        // Reference: riscv-privileged-v1.9.1.pdf - Section 3.1.12, page 28.\\n        uint64 deleg = 0;\\n        uint64 priv = mi.readIflagsPrv();\\n\\n        if (priv <= RiscVConstants.getPrvS()) {\\n            if ((cause & getMcauseInterruptFlag()) != 0) {\\n                // If exception was caused by an interruption the delegated information is\\n                // stored on mideleg register.\\n\\n                // Clear the MCAUSE_INTERRUPT_FLAG() bit before shifting\\n                deleg = (mi.readMideleg() >> (cause & uint64(RiscVConstants.getXlen() - 1))) & 1;\\n            } else {\\n                //If not, information is in the medeleg register\\n                deleg = (mi.readMedeleg() >> cause) & 1;\\n            }\\n        }\\n        if (deleg != 0) {\\n            //is in S mode\\n\\n            // SCAUSE - Supervisor Cause Register\\n            // Register containg Interrupt bit (shows if the exception was cause by an interrupt\\n            // and the Exception code, that identifies the last exception\\n            // The execption codes can be seen at table 4.1\\n            // Reference: riscv-privileged-v1.9.1.pdf - Section 4.1.8, page 51.\\n            mi.writeScause(cause);\\n\\n            // SEPC - Supervisor Exception Program Counter\\n            // When a trap is taken, sepc is written with the address of the instruction\\n            // the encountered the exception.\\n            // Reference: riscv-privileged-v1.9.1.pdf - Section 4.1.7, page 50.\\n            mi.writeSepc(mi.readPc());\\n\\n            // STVAL - Supervisor Trap Value\\n            // stval is written with exception-specific information, when a trap is\\n            // taken into S-Mode. The specific values can be found in Reference.\\n            // Reference: riscv-privileged-v1.10.pdf - Section 4.1.11, page 55.\\n            mi.writeStval(tval);\\n\\n            // MSTATUS - Machine Status Register\\n            // keeps track of and controls hart's current operating state.\\n            // Reference: riscv-privileged-v1.10.pdf - Section 3.1.16, page 19.\\n            uint64 mstatus = mi.readMstatus();\\n\\n            // The SPIE bit indicates whether supervisor interrupts were enabled prior\\n            // to trapping into supervisor mode. When a trap is taken into supervisor\\n            // mode, SPIE is set to SIE, and SIE is set to 0. When an SRET instruction\\n            // is executed, SIE is set to SPIE, then SPIE is set to 1.\\n            // Reference: riscv-privileged-v1.10.pdf - Section 4.1.1, page 19.\\n            mstatus = (mstatus & ~RiscVConstants.getMstatusSpieMask()) | (((mstatus >> RiscVConstants.getPrvS()) & 1) << RiscVConstants.getMstatusSpieShift());\\n\\n            // The SPP bit indicates the privilege level at which a hart was executing\\n            // before entering supervisor mode. When a trap is taken, SPP is set to 0\\n            // if the trap originated from user mode, or 1 otherwise.\\n            // Reference: riscv-privileged-v1.10.pdf - Section 4.1.1, page 49.\\n            mstatus = (mstatus & ~RiscVConstants.getMstatusSppMask()) | (priv << RiscVConstants.getMstatusSppShift());\\n\\n            // The SIE bit enables or disables all interrupts in supervisor mode.\\n            // When SIE is clear, interrupts are not taken while in supervisor mode.\\n            // When the hart is running in user-mode, the value in SIE is ignored, and\\n            // supervisor-level interrupts are enabled. The supervisor can disable\\n            // indivdual interrupt sources using the sie register.\\n            // Reference: riscv-privileged-v1.10.pdf - Section 4.1.1, page 50.\\n            mstatus &= ~RiscVConstants.getMstatusSieMask();\\n\\n            mi.writeMstatus(mstatus);\\n\\n            // TO-DO: Check gas cost to delegate function to library - if its zero the\\n            // if check should move to setPriv()\\n            if (priv != RiscVConstants.getPrvS()) {\\n                mi.setPriv(RiscVConstants.getPrvS());\\n            }\\n            // SVEC - Supervisor Trap Vector Base Address Register\\n            mi.writePc(mi.readStvec());\\n        } else {\\n            // is in M mode\\n            mi.writeMcause(cause);\\n            mi.writeMepc(mi.readPc());\\n            mi.writeMtval(tval);\\n            uint64 mstatus = mi.readMstatus();\\n\\n            mstatus = (mstatus & ~RiscVConstants.getMstatusMpieMask()) | (((mstatus >> RiscVConstants.getPrvM()) & 1) << RiscVConstants.getMstatusMpieShift());\\n            mstatus = (mstatus & ~RiscVConstants.getMstatusMppMask()) | (priv << RiscVConstants.getMstatusMppShift());\\n\\n            mstatus &= ~RiscVConstants.getMstatusMieMask();\\n            mi.writeMstatus(mstatus);\\n\\n            // TO-DO: Check gas cost to delegate function to library - if its zero the\\n            // if check should move to setPriv()\\n            if (priv != RiscVConstants.getPrvM()) {\\n                mi.setPriv(RiscVConstants.getPrvM());\\n            }\\n            mi.writePc(mi.readMtvec());\\n        }\\n    }\\n\\n    function getMcauseInsnAddressMisaligned() public pure returns(uint64) {return 0x0;}\\n    function getMcauseInsnAccessFault() public pure returns(uint64) {return 0x1;}\\n    function getMcauseIllegalInsn() public pure returns(uint64) {return 0x2;}\\n    function getMcauseBreakpoint() public pure returns(uint64) {return 0x3;}\\n    function getMcauseLoadAddressMisaligned() public pure returns(uint64) {return 0x4;}\\n    function getMcauseLoadAccessFault() public pure returns(uint64) {return 0x5;}\\n    function getMcauseStoreAmoAddressMisaligned () public pure returns(uint64) {return 0x6;}\\n    function getMcauseStoreAmoAccessFault() public pure returns(uint64) {return 0x7;}\\n    function getMcauseEcallBase() public pure returns(uint64) {return 0x8;}\\n    function getMcauseFetchPageFault() public pure returns(uint64) {return 0xc;}\\n    function getMcauseLoadPageFault() public pure returns(uint64) {return 0xd;}\\n    function getMcauseStoreAmoPageFault() public pure returns(uint64) {return 0xf;}\\n\\n    function getMcauseInterruptFlag() public pure returns(uint64) {return uint64(1) << uint64(RiscVConstants.getXlen() - 1);}\\n\\n}\\n\",\"keccak256\":\"0x3fa269090a0139e917f0ad30d087b26329db05b90edea5e08366843dd993064e\",\"license\":\"Apache-2.0\"},\"contracts/HTIF.sol\":{\"content\":\"// Copyright 2019 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\n\\n\\n// @title HTIF\\npragma solidity ^0.7.0;\\n\\nimport \\\"./MemoryInteractor.sol\\\";\\n\\n\\n/// @title HTIF\\n/// @author Felipe Argento\\n/// @notice Host-Target-Interface (HTIF) mediates communcation with external world.\\n/// @dev Its active addresses are 0x40000000(tohost) and 0x40000008(from host)\\n/// Reference: The Core of Cartesi, v1.02 - Section 3.2 - The Board\\nlibrary HTIF {\\n\\n    uint64 constant HTIF_TOHOST_ADDR_CONST = 0x40008000;\\n    uint64 constant HTIF_FROMHOST_ADDR_CONST = 0x40008008;\\n    uint64 constant HTIF_IYIELD_ADDR_CONST = 0x40008020;\\n\\n    // [c++] enum HTIF_devices\\n    uint64 constant HTIF_DEVICE_HALT = 0;        //< Used to halt machine\\n    uint64 constant HTIF_DEVICE_CONSOLE = 1;     //< Used for console input and output\\n    uint64 constant HTIF_DEVICE_YIELD = 2;       //< Used to yield control back to host\\n\\n    // [c++] enum HTIF_commands\\n    uint64 constant HTIF_HALT_HALT = 0;\\n    uint64 constant HTIF_CONSOLE_GETCHAR = 0;\\n    uint64 constant HTIF_CONSOLE_PUTCHAR = 1;\\n    uint64 constant HTIF_YIELD_AUTOMATIC = 0;\\n    uint64 constant HTIF_YIELD_MANUAL = 1;\\n\\n    /// @notice reads htif\\n    /// @param mi Memory Interactor with which Step function is interacting.\\n    /// @param addr address to read from\\n    /// @param wordSize can be uint8, uint16, uint32 or uint64\\n    /// @return bool if read was successfull\\n    /// @return uint64 pval\\n    function htifRead(\\n        MemoryInteractor mi,\\n        uint64 addr,\\n        uint64 wordSize\\n    )\\n    public returns (bool, uint64)\\n    {\\n        // HTIF reads must be aligned and 8 bytes\\n        if (wordSize != 64 || (addr & 7) != 0) {\\n            return (false, 0);\\n        }\\n\\n        if (addr == HTIF_TOHOST_ADDR_CONST) {\\n            return (true, mi.readHtifTohost());\\n        } else if (addr == HTIF_FROMHOST_ADDR_CONST) {\\n            return (true, mi.readHtifFromhost());\\n        } else {\\n            return (false, 0);\\n        }\\n    }\\n\\n    /// @notice write htif\\n    /// @param mi Memory Interactor with which Step function is interacting.\\n    /// @param addr address to read from\\n    /// @param val value to be written\\n    /// @param wordSize can be uint8, uint16, uint32 or uint64\\n    /// @return bool if write was successfull\\n    function htifWrite(\\n        MemoryInteractor mi,\\n        uint64 addr,\\n        uint64 val,\\n        uint64 wordSize\\n    )\\n    public returns (bool)\\n    {\\n        // HTIF writes must be aligned and 8 bytes\\n        if (wordSize != 64 || (addr & 7) != 0) {\\n            return false;\\n        }\\n        if (addr == HTIF_TOHOST_ADDR_CONST) {\\n            return htifWriteTohost(mi, val);\\n        } else if (addr == HTIF_FROMHOST_ADDR_CONST) {\\n            mi.writeHtifFromhost(val);\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    // Internal functions\\n    function htifWriteFromhost(MemoryInteractor mi, uint64 val)\\n    internal returns (bool)\\n    {\\n        mi.writeHtifFromhost(val);\\n        // TO-DO: check if h is interactive? reset from host? pollConsole?\\n        return true;\\n    }\\n\\n    function htifWriteTohost(MemoryInteractor mi, uint64 tohost)\\n    internal returns (bool)\\n    {\\n        uint32 device = uint32(tohost >> 56);\\n        uint32 cmd = uint32((tohost >> 48) & 0xff);\\n        uint64 payload = uint32((tohost & (~(uint256(1) >> 16))));\\n\\n        mi.writeHtifTohost(tohost);\\n\\n        if (device == HTIF_DEVICE_HALT) {\\n            return htifHalt(\\n                mi,\\n                cmd,\\n                payload);\\n        } else if (device == HTIF_DEVICE_CONSOLE) {\\n            return htifConsole(\\n                mi,\\n                cmd,\\n                payload);\\n        } else if (device == HTIF_DEVICE_YIELD) {\\n            return htifYield(\\n                mi,\\n                cmd,\\n                payload);\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    function htifHalt(\\n        MemoryInteractor mi,\\n        uint64 cmd,\\n        uint64 payload)\\n    internal returns (bool)\\n    {\\n        if (cmd == HTIF_HALT_HALT && ((payload & 1) == 1) ) {\\n            //set iflags to halted\\n            mi.setIflagsH(true);\\n        }\\n        return true;\\n    }\\n\\n    function htifYield(\\n        MemoryInteractor mi,\\n        uint64 cmd,\\n        uint64 payload)\\n    internal returns (bool)\\n    {\\n        // If yield command is enabled, yield\\n        if ((mi.readHtifIYield() >> cmd) & 1 == 1) {\\n            if (cmd == HTIF_YIELD_MANUAL) {\\n                mi.setIflagsY(true);\\n            } else {\\n                mi.setIflagsX(true);\\n            }\\n            mi.writeHtifFromhost((HTIF_DEVICE_YIELD << 56) | cmd << 48);\\n        }\\n\\n        return true;\\n    }\\n\\n    function htifConsole(\\n        MemoryInteractor mi,\\n        uint64 cmd,\\n        uint64 payload)\\n    internal returns (bool)\\n    {\\n        if (cmd == HTIF_CONSOLE_PUTCHAR) {\\n            htifPutchar(mi);\\n        } else if (cmd == HTIF_CONSOLE_GETCHAR) {\\n            htifGetchar(mi);\\n        } else {\\n            // Unknown HTIF console commands are silently ignored\\n            return true;\\n        }\\n    }\\n\\n    function htifPutchar(MemoryInteractor mi) internal\\n    returns (bool)\\n    {\\n        // TO-DO: what to do in the blockchain? Generate event?\\n        mi.writeHtifFromhost((HTIF_DEVICE_CONSOLE << 56) | uint64(HTIF_CONSOLE_PUTCHAR) << 48);\\n        return true;\\n    }\\n\\n    function htifGetchar(MemoryInteractor mi) internal\\n    returns (bool)\\n    {\\n        mi.writeHtifFromhost((HTIF_DEVICE_CONSOLE << 56) | uint64(HTIF_CONSOLE_GETCHAR) << 48);\\n        return true;\\n    }\\n\\n    // getters\\n    function getHtifToHostAddr() public pure returns (uint64) {\\n        return HTIF_TOHOST_ADDR_CONST;\\n    }\\n\\n    function getHtifFromHostAddr() public pure returns (uint64) {\\n        return HTIF_FROMHOST_ADDR_CONST;\\n    }\\n\\n    function getHtifIYieldAddr() public pure returns (uint64) {\\n        return HTIF_IYIELD_ADDR_CONST;\\n    }\\n\\n}\\n\",\"keccak256\":\"0xe405f4d53cc628c4526599931da90a696a9f4d6db818428e0e110574a136c451\",\"license\":\"Apache-2.0\"},\"contracts/MemoryInteractor.sol\":{\"content\":\"// Copyright 2019 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\n\\n\\n/// @title MemoryInteractor.sol\\npragma solidity ^0.7.0;\\n\\nimport \\\"./ShadowAddresses.sol\\\";\\nimport \\\"./HTIF.sol\\\";\\nimport \\\"./CLINT.sol\\\";\\nimport \\\"./RiscVConstants.sol\\\";\\nimport \\\"@cartesi/util/contracts/BitsManipulationLibrary.sol\\\";\\n\\n/// @title MemoryInteractor\\n/// @author Felipe Argento\\n/// @notice Bridge between Memory Manager and Step\\n/// @dev Every read performed by mi.memoryRead or mi.write should be followed by an\\n/// @dev endianess swap from little endian to big endian. This is the case because\\n/// @dev EVM is big endian but RiscV is little endian.\\n/// @dev Reference: riscv-spec-v2.2.pdf - Preface to Version 2.0\\n/// @dev Reference: Ethereum yellowpaper - Version 69351d5\\n/// @dev    Appendix H. Virtual Machine Specification\\ncontract MemoryInteractor {\\n\\n    uint256 rwIndex; // read write index\\n    uint64[] rwPositions; // read write positions\\n    bytes8[] rwValues; // read write values\\n    bool[] isRead; // true if access is read, false if its write\\n\\n    function initializeMemory(\\n        uint64[] memory _rwPositions,\\n        bytes8[] memory _rwValues,\\n        bool[] memory _isRead\\n    ) virtual public\\n    {\\n        require(_rwPositions.length == _rwValues.length, \\\"Read/write arrays are not the same size\\\");\\n        require(_rwPositions.length == _isRead.length, \\\"Read/write arrays are not the same size\\\");\\n        rwIndex = 0;\\n        rwPositions = _rwPositions;\\n        rwValues = _rwValues;\\n        isRead = _isRead;\\n    }\\n\\n    function getRWIndex() public view returns (uint256) {\\n        return rwIndex;\\n    }\\n    // Reads\\n    function readX(uint64 registerIndex) public returns (uint64) {\\n        return memoryRead(registerIndex * 8);\\n    }\\n\\n    function readClintMtimecmp() public returns (uint64) {\\n        return memoryRead(CLINT.getClintMtimecmp());\\n    }\\n\\n    function readHtifFromhost() public returns (uint64) {\\n        return memoryRead(HTIF.getHtifFromHostAddr());\\n    }\\n\\n    function readHtifTohost() public returns (uint64) {\\n        return memoryRead(HTIF.getHtifToHostAddr());\\n    }\\n\\n    function readHtifIYield() public returns (uint64) {\\n        return memoryRead(HTIF.getHtifIYieldAddr());\\n    }\\n\\n    function readMie() public returns (uint64) {\\n        return memoryRead(ShadowAddresses.getMie());\\n    }\\n\\n    function readMcause() public returns (uint64) {\\n        return memoryRead(ShadowAddresses.getMcause());\\n    }\\n\\n    function readMinstret() public returns (uint64) {\\n        return memoryRead(ShadowAddresses.getMinstret());\\n    }\\n\\n    function readMcycle() public returns (uint64) {\\n        return memoryRead(ShadowAddresses.getMcycle());\\n    }\\n\\n    function readMcounteren() public returns (uint64) {\\n        return memoryRead(ShadowAddresses.getMcounteren());\\n    }\\n\\n    function readMepc() public returns (uint64) {\\n        return memoryRead(ShadowAddresses.getMepc());\\n    }\\n\\n    function readMip() public returns (uint64) {\\n        return memoryRead(ShadowAddresses.getMip());\\n    }\\n\\n    function readMtval() public returns (uint64) {\\n        return memoryRead(ShadowAddresses.getMtval());\\n    }\\n\\n    function readMvendorid() public returns (uint64) {\\n        return memoryRead(ShadowAddresses.getMvendorid());\\n    }\\n\\n    function readMarchid() public returns (uint64) {\\n        return memoryRead(ShadowAddresses.getMarchid());\\n    }\\n\\n    function readMimpid() public returns (uint64) {\\n        return memoryRead(ShadowAddresses.getMimpid());\\n    }\\n\\n    function readMscratch() public returns (uint64) {\\n        return memoryRead(ShadowAddresses.getMscratch());\\n    }\\n\\n    function readSatp() public returns (uint64) {\\n        return memoryRead(ShadowAddresses.getSatp());\\n    }\\n\\n    function readScause() public returns (uint64) {\\n        return memoryRead(ShadowAddresses.getScause());\\n    }\\n\\n    function readSepc() public returns (uint64) {\\n        return memoryRead(ShadowAddresses.getSepc());\\n    }\\n\\n    function readScounteren() public returns (uint64) {\\n        return memoryRead(ShadowAddresses.getScounteren());\\n    }\\n\\n    function readStval() public returns (uint64) {\\n        return memoryRead(ShadowAddresses.getStval());\\n    }\\n\\n    function readMideleg() public returns (uint64) {\\n        return memoryRead(ShadowAddresses.getMideleg());\\n    }\\n\\n    function readMedeleg() public returns (uint64) {\\n        return memoryRead(ShadowAddresses.getMedeleg());\\n    }\\n\\n    function readMtvec() public returns (uint64) {\\n        return memoryRead(ShadowAddresses.getMtvec());\\n    }\\n\\n    function readIlrsc() public returns (uint64) {\\n        return memoryRead(ShadowAddresses.getIlrsc());\\n    }\\n\\n    function readPc() public returns (uint64) {\\n        return memoryRead(ShadowAddresses.getPc());\\n    }\\n\\n    function readSscratch() public returns (uint64) {\\n        return memoryRead(ShadowAddresses.getSscratch());\\n    }\\n\\n    function readStvec() public returns (uint64) {\\n        return memoryRead(ShadowAddresses.getStvec());\\n    }\\n\\n    function readMstatus() public returns (uint64) {\\n        return memoryRead(ShadowAddresses.getMstatus());\\n    }\\n\\n    function readMisa() public returns (uint64) {\\n        return memoryRead(ShadowAddresses.getMisa());\\n    }\\n\\n    function readIflags() public returns (uint64) {\\n        return memoryRead(ShadowAddresses.getIflags());\\n    }\\n\\n    function readIflagsPrv() public returns (uint64) {\\n        return (memoryRead(ShadowAddresses.getIflags()) & RiscVConstants.getIflagsPrvMask()) >> RiscVConstants.getIflagsPrvShift();\\n    }\\n\\n    function readIflagsH() public returns (uint64) {\\n        return (memoryRead(ShadowAddresses.getIflags()) & RiscVConstants.getIflagsHMask()) >> RiscVConstants.getIflagsHShift();\\n    }\\n\\n    function readIflagsY() public returns (uint64) {\\n        return (memoryRead(ShadowAddresses.getIflags()) & RiscVConstants.getIflagsYMask()) >> RiscVConstants.getIflagsYShift();\\n    }\\n\\n    function readIflagsX() public returns (uint64) {\\n        return (memoryRead(ShadowAddresses.getIflags()) & RiscVConstants.getIflagsXMask()) >> RiscVConstants.getIflagsXShift();\\n    }\\n\\n    function readMemory(uint64 paddr, uint64 wordSize) public returns (uint64) {\\n        // get relative address from unaligned paddr\\n        uint64 closestStartAddr = paddr & uint64(~7);\\n        uint64 relAddr = paddr - closestStartAddr;\\n\\n        // value just like its on MM, without endianess swap\\n        uint64 val = pureMemoryRead(closestStartAddr);\\n\\n        // mask to clean a piece of the value that was on memory\\n        uint64 valueMask = BitsManipulationLibrary.uint64SwapEndian(((uint64(2) ** wordSize) - 1) << relAddr*8);\\n        val = BitsManipulationLibrary.uint64SwapEndian(val & valueMask) >> relAddr*8;\\n        return val;\\n    }\\n\\n    // Sets\\n    function setPriv(uint64 newPriv) public {\\n        writeIflagsPrv(newPriv);\\n        writeIlrsc(uint64(-1)); // invalidate reserved address\\n    }\\n\\n    function setMip(uint64 mask) public {\\n        uint64 mip = readMip();\\n        mip |= mask;\\n        writeMip(mip);\\n    }\\n\\n    function resetMip(uint64 mask) public {\\n        uint64 mip = readMip();\\n        mip &= ~mask;\\n        writeMip(mip);\\n    }\\n\\n    // Writes\\n    function writeMie(uint64 value) public {\\n        memoryWrite(ShadowAddresses.getMie(), value);\\n    }\\n\\n    function writeStvec(uint64 value) public {\\n        memoryWrite(ShadowAddresses.getStvec(), value);\\n    }\\n\\n    function writeSscratch(uint64 value) public {\\n        memoryWrite(ShadowAddresses.getSscratch(), value);\\n    }\\n\\n    function writeMip(uint64 value) public {\\n        memoryWrite(ShadowAddresses.getMip(), value);\\n    }\\n\\n    function writeSatp(uint64 value) public {\\n        memoryWrite(ShadowAddresses.getSatp(), value);\\n    }\\n\\n    function writeMedeleg(uint64 value) public {\\n        memoryWrite(ShadowAddresses.getMedeleg(), value);\\n    }\\n\\n    function writeMideleg(uint64 value) public {\\n        memoryWrite(ShadowAddresses.getMideleg(), value);\\n    }\\n\\n    function writeMtvec(uint64 value) public {\\n        memoryWrite(ShadowAddresses.getMtvec(), value);\\n    }\\n\\n    function writeMcounteren(uint64 value) public {\\n        memoryWrite(ShadowAddresses.getMcounteren(), value);\\n    }\\n\\n    function writeMcycle(uint64 value) public {\\n        memoryWrite(ShadowAddresses.getMcycle(), value);\\n    }\\n\\n    function writeMinstret(uint64 value) public {\\n        memoryWrite(ShadowAddresses.getMinstret(), value);\\n    }\\n\\n    function writeMscratch(uint64 value) public {\\n        memoryWrite(ShadowAddresses.getMscratch(), value);\\n    }\\n\\n    function writeScounteren(uint64 value) public {\\n        memoryWrite(ShadowAddresses.getScounteren(), value);\\n    }\\n\\n    function writeScause(uint64 value) public {\\n        memoryWrite(ShadowAddresses.getScause(), value);\\n    }\\n\\n    function writeSepc(uint64 value) public {\\n        memoryWrite(ShadowAddresses.getSepc(), value);\\n    }\\n\\n    function writeStval(uint64 value) public {\\n        memoryWrite(ShadowAddresses.getStval(), value);\\n    }\\n\\n    function writeMstatus(uint64 value) public {\\n        memoryWrite(ShadowAddresses.getMstatus(), value);\\n    }\\n\\n    function writeMcause(uint64 value) public {\\n        memoryWrite(ShadowAddresses.getMcause(), value);\\n    }\\n\\n    function writeMepc(uint64 value) public {\\n        memoryWrite(ShadowAddresses.getMepc(), value);\\n    }\\n\\n    function writeMtval(uint64 value) public {\\n        memoryWrite(ShadowAddresses.getMtval(), value);\\n    }\\n\\n    function writePc(uint64 value) public {\\n        memoryWrite(ShadowAddresses.getPc(), value);\\n    }\\n\\n    function writeIlrsc(uint64 value) public {\\n        memoryWrite(ShadowAddresses.getIlrsc(), value);\\n    }\\n\\n    function writeClintMtimecmp(uint64 value) public {\\n        memoryWrite(CLINT.getClintMtimecmp(), value);\\n    }\\n\\n    function writeHtifFromhost(uint64 value) public {\\n        memoryWrite(HTIF.getHtifFromHostAddr(), value);\\n    }\\n\\n    function writeHtifTohost(uint64 value) public {\\n        memoryWrite(HTIF.getHtifToHostAddr(), value);\\n    }\\n\\n    function setIflagsH(bool halt) public {\\n        uint64 iflags = readIflags();\\n\\n        if (halt) {\\n            iflags = (iflags | RiscVConstants.getIflagsHMask());\\n        } else {\\n            iflags = (iflags & ~RiscVConstants.getIflagsHMask());\\n        }\\n\\n        memoryWrite(ShadowAddresses.getIflags(), iflags);\\n    }\\n\\n    function setIflagsY(bool isManualYield) public {\\n        uint64 iflags = readIflags();\\n\\n        if (isManualYield) {\\n            iflags = (iflags | RiscVConstants.getIflagsYMask());\\n        } else {\\n            iflags = (iflags & ~RiscVConstants.getIflagsYMask());\\n        }\\n\\n        memoryWrite(ShadowAddresses.getIflags(), iflags);\\n    }\\n\\n    function setIflagsX(bool isAutomaticYield) public {\\n        uint64 iflags = readIflags();\\n\\n        if (isAutomaticYield) {\\n            iflags = (iflags | RiscVConstants.getIflagsXMask());\\n        } else {\\n            iflags = (iflags & ~RiscVConstants.getIflagsXMask());\\n        }\\n\\n        memoryWrite(ShadowAddresses.getIflags(), iflags);\\n    }\\n\\n    function writeIflagsPrv(uint64 newPriv) public {\\n        uint64 iflags = readIflags();\\n\\n        // Clears bits 3 and 2 of iflags and use or to set new value\\n        iflags = (iflags & (~RiscVConstants.getIflagsPrvMask())) | (newPriv << RiscVConstants.getIflagsPrvShift());\\n\\n        memoryWrite(ShadowAddresses.getIflags(), iflags);\\n    }\\n\\n    function writeMemory(\\n        uint64 paddr,\\n        uint64 value,\\n        uint64 wordSize\\n    ) public\\n    {\\n        uint64 numberOfBytes = wordSize / 8;\\n\\n        if (numberOfBytes == 8) {\\n            memoryWrite(paddr, value);\\n        } else {\\n            // get relative address from unaligned paddr\\n            uint64 closestStartAddr = paddr & uint64(~7);\\n            uint64 relAddr = paddr - closestStartAddr;\\n\\n            // oldvalue just like its on MM, without endianess swap\\n            uint64 oldVal = pureMemoryRead(closestStartAddr);\\n\\n            // Mask to clean a piece of the value that was on memory\\n            uint64 valueMask = BitsManipulationLibrary.uint64SwapEndian(((uint64(2) ** wordSize) - 1) << relAddr*8);\\n\\n            // value is big endian, need to swap before further operation\\n            uint64 valueSwap = BitsManipulationLibrary.uint64SwapEndian(value & ((uint64(2) ** wordSize) - 1));\\n\\n            uint64 newvalue = ((oldVal & ~valueMask) | (valueSwap >> relAddr*8));\\n\\n            newvalue = BitsManipulationLibrary.uint64SwapEndian(newvalue);\\n            memoryWrite(closestStartAddr, newvalue);\\n        }\\n    }\\n\\n    function writeX(uint64 registerindex, uint64 value) public {\\n        memoryWrite(registerindex * 8, value);\\n    }\\n\\n    // Internal functions\\n    function memoryRead(uint64 _readAddress) public returns (uint64) {\\n        return BitsManipulationLibrary.uint64SwapEndian(\\n            uint64(memoryAccessManager(_readAddress, true))\\n        );\\n    }\\n\\n    function memoryWrite(uint64 _writeAddress, uint64 _value) virtual public {\\n        bytes8 bytesvalue = bytes8(BitsManipulationLibrary.uint64SwapEndian(_value));\\n        require(memoryAccessManager(_writeAddress, false) == bytesvalue, \\\"Written value does not match\\\");\\n    }\\n\\n    // Memory Write without endianess swap\\n    function pureMemoryWrite(uint64 _writeAddress, uint64 _value) virtual internal {\\n        require(\\n            memoryAccessManager(_writeAddress, false) == bytes8(_value),\\n            \\\"Written value does not match\\\"\\n        );\\n    }\\n\\n    // Memory Read without endianess swap\\n    function pureMemoryRead(uint64 _readAddress) internal returns (uint64) {\\n        return uint64(memoryAccessManager(_readAddress, true));\\n    }\\n\\n   // Private functions\\n\\n    // takes care of read/write access\\n    function memoryAccessManager(uint64 _address, bool _accessIsRead) internal virtual returns (bytes8) {\\n        require(isRead[rwIndex] == _accessIsRead, \\\"Access was not the correct type\\\");\\n\\n        uint64 position = rwPositions[rwIndex];\\n        bytes8 value = rwValues[rwIndex];\\n        rwIndex++;\\n\\n        require((position & 7) == 0, \\\"Position is not aligned\\\");\\n        require(position == _address, \\\"Position and read address do not match\\\");\\n\\n        return value;\\n    }\\n}\\n\\n\",\"keccak256\":\"0x9e466150265fbad34ff88e9425c62452c13fafccbdf9a65dcda0a31db0cd21d4\",\"license\":\"Apache-2.0\"},\"contracts/PMA.sol\":{\"content\":\"// Copyright 2019 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\n\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"./MemoryInteractor.sol\\\";\\n\\n/// @title PMA\\n/// @author Felipe Argento\\n/// @notice Implements PMA behaviour\\nlibrary PMA {\\n\\n    uint64 constant MEMORY_ID = 0; //< DID for memory\\n    uint64 constant SHADOW_ID = 1; //< DID for shadow device\\n    uint64 constant DRIVE_ID = 2;  //< DID for drive device\\n    uint64 constant CLINT_ID = 3;  //< DID for CLINT device\\n    uint64 constant HTIF_ID = 4;   //< DID for HTIF device\\n\\n    /// @notice Finds PMA that contains target physical address.\\n    /// @param mi Memory Interactor with which Step function is interacting.\\n    //  contains the logs for this Step execution.\\n    /// @param paddr Target physical address.\\n    /// @return start of pma if found. If not, returns (0)\\n    function findPmaEntry(MemoryInteractor mi, uint64 paddr) public returns (uint64) {\\n        // Hard coded ram address starts at 0x800\\n        // In total there are 32 PMAs from processor shadow to Flash disk 7.\\n        // PMA 0 - describes RAM and is hardcoded to address 0x800\\n        // PMA 16 - 23 describe flash devices 0-7\\n        // RAM start field is hardcoded to 0x800\\n        // Reference: The Core of Cartesi, v1.02 - Table 3.\\n        uint64 pmaAddress = 0x800;\\n        uint64 lastPma = 62; // 0 - 31 * 2 words\\n\\n        for (uint64 i = 0; i <= lastPma; i += 2) {\\n            uint64 startWord = mi.memoryRead(pmaAddress + (i * 8));\\n\\n            uint64 lengthWord = mi.memoryRead(pmaAddress + ((i * 8 + 8)));\\n\\n            uint64 pmaStart = pmaGetStart(startWord);\\n            uint64 pmaLength = pmaGetLength(lengthWord);\\n\\n            // TO-DO: fix overflow possibility\\n            if (paddr >= pmaStart && paddr <= (pmaStart + pmaLength)) {\\n                return startWord;\\n            }\\n\\n            if (pmaLength == 0) {\\n                break;\\n            }\\n        }\\n\\n        return 0;\\n    }\\n\\n    // M bit defines if the range is memory\\n    // The flag is pmaEntry start's word first bit\\n    // Reference: The Core of Cartesi, v1.02 - figure 2.\\n    function pmaGetIstartM(uint64 start) public pure returns (bool) {\\n        return start & 1 == 1;\\n    }\\n\\n    // X bit defines if the range is executable\\n    // The flag is pmaEntry start's word on position 5.\\n    // Reference: The Core of Cartesi, v1.02 - figure 2.\\n    function pmaGetIstartX(uint64 start) public pure returns (bool) {\\n        return (start >> 5) & 1 == 1;\\n    }\\n\\n    // E bit defines if the range is excluded\\n    // The flag is pmaEntry start's word third bit\\n    // Reference: The Core of Cartesi, v1.02 - figure 2.\\n    function pmaGetIstartE(uint64 start) public pure returns (bool) {\\n        return (start >> 2) & 1 == 1;\\n    }\\n\\n    // W bit defines write permission\\n    // The flag is pmaEntry start's word bit on position 4\\n    // Reference: The Core of Cartesi, v1.02 - figure 2.\\n    function pmaGetIstartW(uint64 start) public pure returns (bool) {\\n        return (start >> 4) & 1 == 1;\\n    }\\n\\n    // R bit defines read permission\\n    // The flag is pmaEntry start's word bit on position 3\\n    // Reference: The Core of Cartesi, v1.02 - figure 2.\\n    function pmaGetIstartR(uint64 start) public pure returns (bool) {\\n        return (start >> 3) & 1 == 1;\\n    }\\n\\n    function pmaIsCLINT(uint64 startWord) public pure returns (bool) {\\n        return pmaGetDID(startWord) == CLINT_ID;\\n    }\\n\\n    function pmaIsHTIF(uint64 startWord) public pure returns (bool) {\\n        return pmaGetDID(startWord) == HTIF_ID;\\n    }\\n\\n    // Both pmaStart and pmaLength have to be aligned to a 4KiB boundary.\\n    // So this leaves the lowest 12 bits for attributes. To find out the actual\\n    // start and length of the PMAs it is necessary to clean those attribute bits\\n    // Reference: The Core of Cartesi, v1.02 - Figure 2 - Page 5.\\n    function pmaGetStart(uint64 startWord) internal pure returns (uint64) {\\n        return startWord & 0xfffffffffffff000;\\n    }\\n\\n    function pmaGetLength(uint64 lengthWord) internal pure returns (uint64) {\\n        return lengthWord & 0xfffffffffffff000;\\n    }\\n\\n    // DID is encoded on bytes 8 - 11 of pma's start word.\\n    // It defines the devices id.\\n    // 0 for memory ranges\\n    // 1 for shadows\\n    // 1 for drive\\n    // 3 for CLINT\\n    // 4 for HTIF\\n    // Reference: The Core of Cartesi, v1.02 - Figure 2 - Page 5.\\n    function pmaGetDID(uint64 startWord) internal pure returns (uint64) {\\n        return (startWord >> 8) & 0x0F;\\n    }\\n\\n}\\n\",\"keccak256\":\"0xd04a7d5e93d2a15458aee4c8851a876e51f56f23c5e3ae25e9aef93a61f36e33\",\"license\":\"Apache-2.0\"},\"contracts/RealTimeClock.sol\":{\"content\":\"// Copyright 2019 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\n\\n\\n/// @title RealTimeClock\\npragma solidity ^0.7.0;\\n\\n/// @title RealTimeClock\\n/// @author Felipe Argento\\n/// @notice Real Time clock simulator\\nlibrary RealTimeClock {\\n    uint64 constant RTC_FREQ_DIV = 100;\\n    \\n    /// @notice Converts from cycle count to time count\\n    /// @param cycle Cycle count\\n    /// @return Time count\\n    function rtcCycleToTime(uint64 cycle) public pure returns (uint64) {\\n        return cycle / RTC_FREQ_DIV;\\n    }\\n\\n    /// @notice Converts from time count to cycle count\\n    /// @param  time Time count\\n    /// @return Cycle count\\n    function rtcTimeToCycle(uint64 time) public pure returns (uint64) {\\n        return time * RTC_FREQ_DIV;\\n    }\\n\\n    /// @notice Returns whether the cycle is a RTC tick\\n    /// @param cycle Cycle count\\n    function rtcIsTick(uint64 cycle) public pure returns (bool) {\\n        return (cycle % RTC_FREQ_DIV) == 0;\\n    }\\n}\\n\",\"keccak256\":\"0x0513dabae4453feab3a4009eef3ddc7ba4719ac6577140c156c7afc0520acf27\",\"license\":\"Apache-2.0\"},\"contracts/RiscVConstants.sol\":{\"content\":\"// Copyright 2019 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\n\\n\\npragma solidity ^0.7.0;\\n\\n/// @title RiscVConstants\\n/// @author Felipe Argento\\n/// @notice Defines getters for important constants\\nlibrary RiscVConstants {\\n    //iflags shifts\\n    function getIflagsHShift()  public pure returns(uint64) {return 0;}\\n    function getIflagsYShift()  public pure returns(uint64) {return 1;}\\n    function getIflagsXShift()  public pure returns(uint64) {return 2;}\\n    function getIflagsPrvShift()  public pure returns(uint64) {return 3;}\\n\\n    //iflags masks\\n    function getIflagsHMask()  public pure returns(uint64) {return uint64(1) << getIflagsHShift();}\\n    function getIflagsYMask()  public pure returns(uint64) {return uint64(1) << getIflagsYShift();}\\n    function getIflagsXMask()  public pure returns(uint64) {return uint64(1) << getIflagsXShift();}\\n    function getIflagsPrvMask()  public pure returns(uint64) {return uint64(3) << getIflagsPrvShift();}\\n\\n    //general purpose\\n    function getXlen() public pure returns(uint64) {return 64;}\\n    function getMxl()  public pure returns(uint64) {return 2;}\\n\\n    //privilege levels\\n    function getPrvU() public pure returns(uint64) {return 0;}\\n    function getPrvS() public pure returns(uint64) {return 1;}\\n    function getPrvH() public pure returns(uint64) {return 2;}\\n    function getPrvM() public pure returns(uint64) {return 3;}\\n\\n    //mstatus shifts\\n    function getMstatusUieShift()  public pure returns(uint64) {return 0;}\\n    function getMstatusSieShift()  public pure returns(uint64) {return 1;}\\n    function getMstatusHieShift()  public pure returns(uint64) {return 2;}\\n    function getMstatusMieShift()  public pure returns(uint64) {return 3;}\\n    function getMstatusUpieShift() public pure returns(uint64) {return 4;}\\n    function getMstatusSpieShift() public pure returns(uint64) {return 5;}\\n    function getMstatusMpieShift() public pure returns(uint64) {return 7;}\\n    function getMstatusSppShift()  public pure returns(uint64) {return 8;}\\n    function getMstatusMppShift()  public pure returns(uint64) {return 11;}\\n    function getMstatusFsShift()   public pure returns(uint64) {return 13;}\\n\\n    function getMstatusXsShift()   public pure returns(uint64) {return 15;}\\n    function getMstatusMprvShift() public pure returns(uint64) {return 17;}\\n    function getMstatusSumShift()  public pure returns(uint64) {return 18;}\\n    function getMstatusMxrShift()  public pure returns(uint64) {return 19;}\\n    function getMstatusTvmShift()  public pure returns(uint64) {return 20;}\\n    function getMstatusTwShift()   public pure returns(uint64) {return 21;}\\n    function getMstatusTsrShift()  public pure returns(uint64) {return 22;}\\n\\n\\n    function getMstatusUxlShift()  public pure returns(uint64) {return 32;}\\n    function getMstatusSxlShift()  public pure returns(uint64) {return 34;}\\n\\n    function getMstatusSdShift()   public pure returns(uint64) {return getXlen() - 1;}\\n\\n    //mstatus masks\\n    function getMstatusUieMask()  public pure returns(uint64) {return (uint64(1) << getMstatusUieShift());}\\n    function getMstatusSieMask()  public pure returns(uint64) {return uint64(1) << getMstatusSieShift();}\\n    function getMstatusMieMask()  public pure returns(uint64) {return uint64(1) << getMstatusMieShift();}\\n    function getMstatusUpieMask() public pure returns(uint64) {return uint64(1) << getMstatusUpieShift();}\\n    function getMstatusSpieMask() public pure returns(uint64) {return uint64(1) << getMstatusSpieShift();}\\n    function getMstatusMpieMask() public pure returns(uint64) {return uint64(1) << getMstatusMpieShift();}\\n    function getMstatusSppMask()  public pure returns(uint64) {return uint64(1) << getMstatusSppShift();}\\n    function getMstatusMppMask()  public pure returns(uint64) {return uint64(3) << getMstatusMppShift();}\\n    function getMstatusFsMask()   public pure returns(uint64) {return uint64(3) << getMstatusFsShift();}\\n    function getMstatusXsMask()   public pure returns(uint64) {return uint64(3) << getMstatusXsShift();}\\n    function getMstatusMprvMask() public pure returns(uint64) {return uint64(1) << getMstatusMprvShift();}\\n    function getMstatusSumMask()  public pure returns(uint64) {return uint64(1) << getMstatusSumShift();}\\n    function getMstatusMxrMask()  public pure returns(uint64) {return uint64(1) << getMstatusMxrShift();}\\n    function getMstatusTvmMask()  public pure returns(uint64) {return uint64(1) << getMstatusTvmShift();}\\n    function getMstatusTwMask()   public pure returns(uint64) {return uint64(1) << getMstatusTwShift();}\\n    function getMstatusTsrMask()  public pure returns(uint64) {return uint64(1) << getMstatusTsrShift();}\\n\\n    function getMstatusUxlMask()  public pure returns(uint64) {return uint64(3) << getMstatusUxlShift();}\\n    function getMstatusSxlMask()  public pure returns(uint64) {return uint64(3) << getMstatusSxlShift();}\\n    function getMstatusSdMask()   public pure returns(uint64) {return uint64(1) << getMstatusSdShift();}\\n\\n    // mstatus read/writes\\n    function getMstatusWMask() public pure returns(uint64) {\\n        return (\\n            getMstatusUieMask()  |\\n            getMstatusSieMask()  |\\n            getMstatusMieMask()  |\\n            getMstatusUpieMask() |\\n            getMstatusSpieMask() |\\n            getMstatusMpieMask() |\\n            getMstatusSppMask()  |\\n            getMstatusMppMask()  |\\n            getMstatusFsMask()   |\\n            getMstatusMprvMask() |\\n            getMstatusSumMask()  |\\n            getMstatusMxrMask()  |\\n            getMstatusTvmMask()  |\\n            getMstatusTwMask()   |\\n            getMstatusTsrMask()\\n        );\\n    }\\n\\n    function getMstatusRMask() public pure returns(uint64) {\\n        return (\\n            getMstatusUieMask()  |\\n            getMstatusSieMask()  |\\n            getMstatusMieMask()  |\\n            getMstatusUpieMask() |\\n            getMstatusSpieMask() |\\n            getMstatusMpieMask() |\\n            getMstatusSppMask()  |\\n            getMstatusMppMask()  |\\n            getMstatusFsMask()   |\\n            getMstatusMprvMask() |\\n            getMstatusSumMask()  |\\n            getMstatusMxrMask()  |\\n            getMstatusTvmMask()  |\\n            getMstatusTwMask()   |\\n            getMstatusTsrMask()  |\\n            getMstatusUxlMask()  |\\n            getMstatusSxlMask()  |\\n            getMstatusSdMask()\\n        );\\n    }\\n\\n    // sstatus read/writes\\n    function getSstatusWMask() public pure returns(uint64) {\\n        return (\\n            getMstatusUieMask()  |\\n            getMstatusSieMask()  |\\n            getMstatusUpieMask() |\\n            getMstatusSpieMask() |\\n            getMstatusSppMask()  |\\n            getMstatusFsMask()   |\\n            getMstatusSumMask()  |\\n            getMstatusMxrMask()\\n        );\\n    }\\n\\n    function getSstatusRMask() public pure returns(uint64) {\\n        return (\\n            getMstatusUieMask()  |\\n            getMstatusSieMask()  |\\n            getMstatusUpieMask() |\\n            getMstatusSpieMask() |\\n            getMstatusSppMask()  |\\n            getMstatusFsMask()   |\\n            getMstatusSumMask()  |\\n            getMstatusMxrMask()  |\\n            getMstatusUxlMask()  |\\n            getMstatusSdMask()\\n        );\\n    }\\n\\n    // mcause for exceptions\\n    function getMcauseInsnAddressMisaligned() public pure returns(uint64) {return 0x0;} ///< instruction address misaligned\\n    function getMcauseInsnAccessFault() public pure returns(uint64) {return 0x1;} ///< instruction access fault\\n    function getMcauseIllegalInsn() public pure returns(uint64) {return 0x2;} ///< illegal instruction\\n    function getMcauseBreakpoint() public pure returns(uint64) {return 0x3;} ///< breakpoint\\n    function getMcauseLoadAddressMisaligned() public pure returns(uint64) {return 0x4;} ///< load address misaligned\\n    function getMcauseLoadAccessFault() public pure returns(uint64) {return 0x5;} ///< load access fault\\n    function getMcauseStoreAmoAddressMisaligned() public pure returns(uint64) {return 0x6;} ///< store/amo address misaligned\\n    function getMcauseStoreAmoAccessFault() public pure returns(uint64) {return 0x7;} ///< store/amo access fault\\n    ///< environment call (+0: from u-mode, +1: from s-mode, +3: from m-mode)\\n    function getMcauseEcallBase() public pure returns(uint64) { return 0x8;}\\n    function getMcauseFetchPageFault() public pure returns(uint64) {return 0xc;} ///< instruction page fault\\n    function getMcauseLoadPageFault() public pure returns(uint64) {return 0xd;} ///< load page fault\\n    function getMcauseStoreAmoPageFault() public pure returns(uint64) {return 0xf;} ///< store/amo page fault\\n\\n    function getMcauseInterruptFlag() public pure returns(uint64) {return uint64(1) << (getXlen() - 1);} ///< interrupt flag\\n\\n    // mcounteren constants\\n    function getMcounterenCyShift() public pure returns(uint64) {return 0;}\\n    function getMcounterenTmShift() public pure returns(uint64) {return 1;}\\n    function getMcounterenIrShift() public pure returns(uint64) {return 2;}\\n\\n    function getMcounterenCyMask() public pure returns(uint64) {return uint64(1) << getMcounterenCyShift();}\\n    function getMcounterenTmMask() public pure returns(uint64) {return uint64(1) << getMcounterenTmShift();}\\n    function getMcounterenIrMask() public pure returns(uint64) {return uint64(1) << getMcounterenIrShift();}\\n\\n    function getMcounterenRwMask() public pure returns(uint64) {return getMcounterenCyMask() | getMcounterenTmMask() | getMcounterenIrMask();}\\n    function getScounterenRwMask() public pure returns(uint64) {return getMcounterenRwMask();}\\n\\n    //paging constants\\n    function getPgShift() public pure returns(uint64) {return 12;}\\n    function getPgMask()  public pure returns(uint64) {((uint64(1) << getPgShift()) - 1);}\\n\\n    function getPteVMask() public pure returns(uint64) {return (1 << 0);}\\n    function getPteUMask() public pure returns(uint64) {return (1 << 4);}\\n    function getPteAMask() public pure returns(uint64) {return (1 << 6);}\\n    function getPteDMask() public pure returns(uint64) {return (1 << 7);}\\n\\n    function getPteXwrReadShift() public pure returns(uint64) {return 0;}\\n    function getPteXwrWriteShift() public pure returns(uint64) {return 1;}\\n    function getPteXwrCodeShift() public pure returns(uint64) {return 2;}\\n\\n    // page masks\\n    function getPageNumberShift() public pure returns(uint64) {return 12;}\\n\\n    function getPageOffsetMask() public pure returns(uint64) {return ((uint64(1) << getPageNumberShift()) - 1);}\\n\\n    // mip shifts:\\n    function getMipUsipShift() public pure returns(uint64) {return 0;}\\n    function getMipSsipShift() public pure returns(uint64) {return 1;}\\n    function getMipMsipShift() public pure returns(uint64) {return 3;}\\n    function getMipUtipShift() public pure returns(uint64) {return 4;}\\n    function getMipStipShift() public pure returns(uint64) {return 5;}\\n    function getMipMtipShift() public pure returns(uint64) {return 7;}\\n    function getMipUeipShift() public pure returns(uint64) {return 8;}\\n    function getMipSeipShift() public pure returns(uint64) {return 9;}\\n    function getMipMeipShift() public pure returns(uint64) {return 11;}\\n\\n    function getMipUsipMask() public pure returns(uint64) {return uint64(1) << getMipUsipShift();}\\n    function getMipSsipMask() public pure returns(uint64) {return uint64(1) << getMipSsipShift();}\\n    function getMipMsipMask() public pure returns(uint64) {return uint64(1) << getMipMsipShift();}\\n    function getMipUtipMask() public pure returns(uint64) {return uint64(1) << getMipUtipShift();}\\n    function getMipStipMask() public pure returns(uint64) {return uint64(1) << getMipStipShift();}\\n    function getMipMtipMask() public pure returns(uint64) {return uint64(1) << getMipMtipShift();}\\n    function getMipUeipMask() public pure returns(uint64) {return uint64(1) << getMipUeipShift();}\\n    function getMipSeipMask() public pure returns(uint64) {return uint64(1) << getMipSeipShift();}\\n    function getMipMeipMask() public pure returns(uint64) {return uint64(1) << getMipMeipShift();}\\n}\\n\",\"keccak256\":\"0xbcb9348cf546206050eda0969c2fb2afb4208463d265dea15aaff26ba5dcc288\",\"license\":\"Apache-2.0\"},\"contracts/RiscVDecoder.sol\":{\"content\":\"// Copyright 2019 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\n\\n\\n// @title RiscVDecoder\\npragma solidity ^0.7.0;\\n\\nimport \\\"@cartesi/util/contracts/BitsManipulationLibrary.sol\\\";\\n\\n/// @title RiscVDecoder\\n/// @author Felipe Argento\\n/// @notice Contract responsible for decoding the riscv's instructions\\n//      It applies different bitwise operations and masks to reach\\n//      specific positions and use that positions to identify the\\n//      correct function to be executed\\nlibrary RiscVDecoder {\\n    /// @notice Get the instruction's RD\\n    /// @param insn Instruction\\n    function insnRd(uint32 insn) public pure returns(uint32) {\\n        return (insn >> 7) & 0x1F;\\n    }\\n\\n    /// @notice Get the instruction's RS1\\n    /// @param insn Instruction\\n    function insnRs1(uint32 insn) public pure returns(uint32) {\\n        return (insn >> 15) & 0x1F;\\n    }\\n\\n    /// @notice Get the instruction's RS2\\n    /// @param insn Instruction\\n    function insnRs2(uint32 insn) public pure returns(uint32) {\\n        return (insn >> 20) & 0x1F;\\n    }\\n\\n    /// @notice Get the I-type instruction's immediate value\\n    /// @param insn Instruction\\n    function insnIImm(uint32 insn) public pure returns(int32) {\\n        return int32(insn) >> 20;\\n    }\\n\\n    /// @notice Get the I-type instruction's unsigned immediate value\\n    /// @param insn Instruction\\n    function insnIUimm(uint32 insn) public pure returns(uint32) {\\n        return insn >> 20;\\n    }\\n\\n    /// @notice Get the U-type instruction's immediate value\\n    /// @param insn Instruction\\n    function insnUImm(uint32 insn) public pure returns(int32) {\\n        return int32(insn & 0xfffff000);\\n    }\\n\\n    /// @notice Get the B-type instruction's immediate value\\n    /// @param insn Instruction\\n    function insnBImm(uint32 insn) public pure returns(int32) {\\n        int32 imm = int32(\\n            ((insn >> (31 - 12)) & (1 << 12)) |\\n            ((insn >> (25 - 5)) & 0x7e0) |\\n            ((insn >> (8 - 1)) & 0x1e) |\\n            ((insn << (11 - 7)) & (1 << 11))\\n        );\\n        return BitsManipulationLibrary.int32SignExtension(imm, 13);\\n    }\\n\\n    /// @notice Get the J-type instruction's immediate value\\n    /// @param insn Instruction\\n    function insnJImm(uint32 insn) public pure returns(int32) {\\n        int32 imm = int32(\\n            ((insn >> (31 - 20)) & (1 << 20)) |\\n            ((insn >> (21 - 1)) & 0x7fe) |\\n            ((insn >> (20 - 11)) & (1 << 11)) |\\n            (insn & 0xff000)\\n        );\\n        return BitsManipulationLibrary.int32SignExtension(imm, 21);\\n    }\\n\\n    /// @notice Get the S-type instruction's immediate value\\n    /// @param insn Instruction\\n    function insnSImm(uint32 insn) public pure returns(int32) {\\n        int32 imm = int32(((insn & 0xfe000000) >> (25 - 5)) | ((insn >> 7) & 0x1F));\\n        return BitsManipulationLibrary.int32SignExtension(imm, 12);\\n    }\\n\\n    /// @notice Get the instruction's opcode field\\n    /// @param insn Instruction\\n    function insnOpcode(uint32 insn) public pure returns (uint32) {\\n        return insn & 0x7F;\\n    }\\n\\n    /// @notice Get the instruction's funct3 field\\n    /// @param insn Instruction\\n    function insnFunct3(uint32 insn) public pure returns (uint32) {\\n        return (insn >> 12) & 0x07;\\n    }\\n\\n    /// @notice Get the concatenation of instruction's funct3 and funct7 fields\\n    /// @param insn Instruction\\n    function insnFunct3Funct7(uint32 insn) public pure returns (uint32) {\\n        return ((insn >> 5) & 0x380) | (insn >> 25);\\n    }\\n\\n    /// @notice Get the concatenation of instruction's funct3 and funct5 fields\\n    /// @param insn Instruction\\n    function insnFunct3Funct5(uint32 insn) public pure returns (uint32) {\\n        return ((insn >> 7) & 0xE0) | (insn >> 27);\\n    }\\n\\n    /// @notice Get the instruction's funct7 field\\n    /// @param insn Instruction\\n    function insnFunct7(uint32 insn) public pure returns (uint32) {\\n        return (insn >> 25) & 0x7F;\\n    }\\n\\n    /// @notice Get the instruction's funct6 field\\n    /// @param insn Instruction\\n    function insnFunct6(uint32 insn) public pure returns (uint32) {\\n        return (insn >> 26) & 0x3F;\\n    }\\n}\\n\",\"keccak256\":\"0xd908b1ffb6386732728562ea6cc57d5ffe71dc2134e8b0f79857882c8a3eac3c\",\"license\":\"Apache-2.0\"},\"contracts/ShadowAddresses.sol\":{\"content\":\"// Copyright 2019 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\n\\n\\npragma solidity ^0.7.0;\\n\\n\\n/// @title ShadowAddresses\\n/// @author Felipe Argento\\n/// @notice Defines the processor state. Memory-mapped to the lowest 512 bytes in pm\\n/// @dev Defined on Cartesi techpaper version 1.02 - Section 3 - table 2 \\n/// Source: https://cartesi.io/cartesi_whitepaper.pdf \\nlibrary ShadowAddresses {\\n    uint64 constant PC         = 0x100;\\n    uint64 constant MVENDORID  = 0x108;\\n    uint64 constant MARCHID    = 0x110;\\n    uint64 constant MIMPID     = 0x118;\\n    uint64 constant MCYCLE     = 0x120;\\n    uint64 constant MINSTRET   = 0x128;\\n    uint64 constant MSTATUS    = 0x130;\\n    uint64 constant MTVEC      = 0x138;\\n    uint64 constant MSCRATCH   = 0x140;\\n    uint64 constant MEPC       = 0x148;\\n    uint64 constant MCAUSE     = 0x150;\\n    uint64 constant MTVAL      = 0x158;\\n    uint64 constant MISA       = 0x160;\\n    uint64 constant MIE        = 0x168;\\n    uint64 constant MIP        = 0x170;\\n    uint64 constant MEDELEG    = 0x178;\\n    uint64 constant MIDELEG    = 0x180;\\n    uint64 constant MCOUNTEREN = 0x188;\\n    uint64 constant STVEC      = 0x190;\\n    uint64 constant SSCRATCH   = 0x198;\\n    uint64 constant SEPC       = 0x1a0;\\n    uint64 constant SCAUSE     = 0x1a8;\\n    uint64 constant STVAL      = 0x1b0;\\n    uint64 constant SATP       = 0x1b8;\\n    uint64 constant SCOUNTEREN = 0x1c0;\\n    uint64 constant ILRSC      = 0x1c8;\\n    uint64 constant IFLAGS     = 0x1d0;\\n\\n    //getters - contracts cant access constants directly\\n    function getPc()         public pure returns(uint64) {return PC;}\\n    function getMvendorid()  public pure returns(uint64) {return MVENDORID;}\\n    function getMarchid()    public pure returns(uint64) {return MARCHID;}\\n    function getMimpid()     public pure returns(uint64) {return MIMPID;}\\n    function getMcycle()     public pure returns(uint64) {return MCYCLE;}\\n    function getMinstret()   public pure returns(uint64) {return MINSTRET;}\\n    function getMstatus()    public pure returns(uint64) {return MSTATUS;}\\n    function getMtvec()      public pure returns(uint64) {return MTVEC;}\\n    function getMscratch()   public pure returns(uint64) {return MSCRATCH;}\\n    function getMepc()       public pure returns(uint64) {return MEPC;}\\n    function getMcause()     public pure returns(uint64) {return MCAUSE;}\\n    function getMtval()      public pure returns(uint64) {return MTVAL;}\\n    function getMisa()       public pure returns(uint64) {return MISA;}\\n    function getMie()        public pure returns(uint64) {return MIE;}\\n    function getMip()        public pure returns(uint64) {return MIP;}\\n    function getMedeleg()    public pure returns(uint64) {return MEDELEG;}\\n    function getMideleg()    public pure returns(uint64) {return MIDELEG;}\\n    function getMcounteren() public pure returns(uint64) {return MCOUNTEREN;}\\n    function getStvec()      public pure returns(uint64) {return STVEC;}\\n    function getSscratch()   public pure returns(uint64) {return SSCRATCH;}\\n    function getSepc()       public pure returns(uint64) {return SEPC;}\\n    function getScause()     public pure returns(uint64) {return SCAUSE;}\\n    function getStval()      public pure returns(uint64) {return STVAL;}\\n    function getSatp()       public pure returns(uint64) {return SATP;}\\n    function getScounteren() public pure returns(uint64) {return SCOUNTEREN;}\\n    function getIlrsc()      public pure returns(uint64) {return ILRSC;}\\n    function getIflags()     public pure returns(uint64) {return IFLAGS;}\\n}\\n\",\"keccak256\":\"0xbfd187bab76a2802de777406cdddc9fe0cbf79ab8cb6f76075da7db664a9e9ae\",\"license\":\"Apache-2.0\"},\"contracts/VirtualMemory.sol\":{\"content\":\"// Copyright 2019 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\n\\n\\npragma solidity ^0.7.0;\\n\\nimport \\\"./ShadowAddresses.sol\\\";\\nimport \\\"./RiscVConstants.sol\\\";\\nimport \\\"./RiscVDecoder.sol\\\";\\nimport \\\"./MemoryInteractor.sol\\\";\\nimport \\\"./PMA.sol\\\";\\nimport \\\"./CLINT.sol\\\";\\nimport \\\"./HTIF.sol\\\";\\nimport \\\"./Exceptions.sol\\\";\\n\\n/// @title Virtual Memory\\n/// @author Felipe Argento\\n/// @notice Defines Virtual Memory behaviour\\nlibrary VirtualMemory {\\n\\n    // Variable positions on their respective array.\\n    // This is not an enum because enum assumes the type from the number of variables\\n    // So we would have to explicitly cast to uint256 on every single access\\n    uint256 constant PRIV = 0;\\n    uint256 constant MODE= 1;\\n    uint256 constant VADDR_SHIFT = 2;\\n    uint256 constant PTE_SIZE_LOG2 = 3;\\n    uint256 constant VPN_BITS = 4;\\n    uint256 constant SATP_PPN_BITS = 5;\\n\\n    uint256 constant VADDR_MASK = 0;\\n    uint256 constant PTE_ADDR = 1;\\n    uint256 constant MSTATUS = 2;\\n    uint256 constant SATP = 3;\\n    uint256 constant VPN_MASK = 4;\\n    uint256 constant PTE = 5;\\n\\n    // Write/Read Virtual Address variable indexes\\n    uint256 constant OFFSET = 0;\\n    uint256 constant PMA_START = 1;\\n    uint256 constant PADDR = 2;\\n    uint256 constant VAL = 3;\\n\\n    /// @notice Read word to virtual memory\\n    /// @param wordSize can be uint8, uint16, uint32 or uint64\\n    /// @param vaddr is the words virtual address\\n    /// @return True if write was succesfull, false if not.\\n    /// @return Word with receiveing value.\\n    function readVirtualMemory(\\n        MemoryInteractor mi,\\n        uint64 wordSize,\\n        uint64 vaddr\\n    )\\n    public returns(bool, uint64)\\n    {\\n        uint64[6] memory uint64vars;\\n        if (vaddr & (wordSize/8 - 1) != 0) {\\n            // Word is not aligned - raise exception\\n            Exceptions.raiseException(\\n                mi,\\n                Exceptions.getMcauseLoadAddressMisaligned(),\\n                vaddr\\n            );\\n            return (false, 0);\\n        } else {\\n            (bool translateSuccess, uint64 paddr) = translateVirtualAddress(\\n                mi,\\n                vaddr,\\n                RiscVConstants.getPteXwrReadShift()\\n            );\\n\\n            if (!translateSuccess) {\\n                // translation failed - raise exception\\n                Exceptions.raiseException(\\n                    mi,\\n                    Exceptions.getMcauseLoadPageFault(),\\n                    vaddr\\n                );\\n                return (false, 0);\\n            }\\n            uint64vars[PMA_START] = PMA.findPmaEntry(mi, paddr);\\n            if (PMA.pmaGetIstartE(uint64vars[PMA_START]) || !PMA.pmaGetIstartR(uint64vars[PMA_START])) {\\n                // PMA is either excluded or we dont have permission to write - raise exception\\n                Exceptions.raiseException(\\n                    mi,\\n                    Exceptions.getMcauseLoadAccessFault(),\\n                    vaddr\\n                );\\n                return (false, 0);\\n            } else if (PMA.pmaGetIstartM(uint64vars[PMA_START])) {\\n                return (true, mi.readMemory(paddr, wordSize));\\n            }else {\\n                bool success = false;\\n                if (PMA.pmaIsHTIF(uint64vars[PMA_START])) {\\n                    (success, uint64vars[VAL]) = HTIF.htifRead(\\n                        mi,\\n                        paddr,\\n                        wordSize\\n                    );\\n                } else if (PMA.pmaIsCLINT(uint64vars[PMA_START])) {\\n                    (success, uint64vars[VAL]) = CLINT.clintRead(\\n                        mi,\\n                        paddr,\\n                        wordSize\\n                    );\\n                }\\n                if (!success) {\\n                    Exceptions.raiseException(\\n                        mi,\\n                        Exceptions.getMcauseLoadAccessFault(),\\n                        vaddr\\n                    );\\n                }\\n                return (success, uint64vars[VAL]);\\n            }\\n        }\\n    }\\n\\n    /// @notice Writes word to virtual memory\\n    /// @param wordSize can be uint8, uint16, uint32 or uint64\\n    /// @param vaddr is the words virtual address\\n    /// @param val is the value to be written\\n    /// @return True if write was succesfull, false if not.\\n    function writeVirtualMemory(\\n        MemoryInteractor mi,\\n        uint64 wordSize,\\n        uint64 vaddr,\\n        uint64 val\\n    )\\n    public returns (bool)\\n    {\\n        uint64[6] memory uint64vars;\\n\\n        if (vaddr & ((wordSize / 8) - 1) != 0) {\\n            // Word is not aligned - raise exception\\n            Exceptions.raiseException(\\n                mi,\\n                Exceptions.getMcauseStoreAmoAddressMisaligned(),\\n                vaddr\\n            );\\n            return false;\\n        } else {\\n            bool translateSuccess;\\n            (translateSuccess, uint64vars[PADDR]) = translateVirtualAddress(\\n                mi,\\n                vaddr,\\n                RiscVConstants.getPteXwrWriteShift()\\n            );\\n\\n            if (!translateSuccess) {\\n                // translation failed - raise exception\\n                Exceptions.raiseException(\\n                    mi,\\n                    Exceptions.getMcauseStoreAmoPageFault(),\\n                    vaddr);\\n\\n                return false;\\n            }\\n            uint64vars[PMA_START] = PMA.findPmaEntry(mi, uint64vars[PADDR]);\\n\\n            if (PMA.pmaGetIstartE(uint64vars[PMA_START]) || !PMA.pmaGetIstartW(uint64vars[PMA_START])) {\\n                // PMA is either excluded or we dont have permission to write - raise exception\\n                Exceptions.raiseException(\\n                    mi,\\n                    Exceptions.getMcauseStoreAmoAccessFault(),\\n                    vaddr\\n                );\\n                return false;\\n            } else if (PMA.pmaGetIstartM(uint64vars[PMA_START])) {\\n                //write to memory\\n                mi.writeMemory(\\n                    uint64vars[PADDR],\\n                    val,\\n                    wordSize\\n                );\\n                return true;\\n            } else {\\n\\n                if (PMA.pmaIsHTIF(uint64vars[PMA_START])) {\\n                    if (!HTIF.htifWrite(\\n                       mi,\\n                       PMA.pmaGetStart(uint64vars[PMA_START]), val, wordSize\\n                    )) {\\n                        Exceptions.raiseException(\\n                            mi,\\n                            Exceptions.getMcauseStoreAmoAccessFault(),\\n                            vaddr\\n                        );\\n                        return false;\\n                    }\\n                } else if (PMA.pmaIsCLINT(uint64vars[PMA_START])) {\\n                    if (!CLINT.clintWrite(\\n                            mi,\\n                            PMA.pmaGetStart(uint64vars[PMA_START]), val, wordSize\\n                    )) {\\n                        Exceptions.raiseException(\\n                            mi,\\n                            Exceptions.getMcauseStoreAmoAccessFault(),\\n                            vaddr\\n                        );\\n                        return false;\\n                    }\\n                }\\n                return true;\\n            }\\n        }\\n    }\\n\\n    // Finds the physical address associated to the virtual address (vaddr).\\n    // Walks the page table until it finds a valid one. Returns a bool if the physical\\n    // address was succesfully found along with the address. Returns false and zer0\\n    // if something went wrong.\\n\\n    // Virtual Address Translation proccess is defined, step by step on the following Reference:\\n    // Reference: riscv-priv-spec-1.10.pdf - Section 4.3.2, page 62.\\n    function translateVirtualAddress(\\n        MemoryInteractor mi,\\n        uint64 vaddr,\\n        int xwrShift\\n    )\\n    public returns(bool, uint64)\\n    {\\n        //TO-DO: check shift + mask\\n        //TO-DO: use bitmanipulation right shift\\n\\n        // Through arrays we force variables that were being put on stack to be stored\\n        // in memory. It is more expensive, but the stack only supports 16 variables.\\n        uint64[6] memory uint64vars;\\n        int[6] memory intvars;\\n\\n        // Reads privilege level on iflags register. The privilege level is located\\n        // on bits 2 and 3.\\n        // Reference: The Core of Cartesi, v1.02 - figure 1.\\n        intvars[PRIV] = mi.readIflagsPrv();\\n\\n        //readMstatus\\n        uint64vars[MSTATUS] = mi.memoryRead(ShadowAddresses.getMstatus());\\n\\n        // When MPRV is set, data loads and stores use privilege in MPP\\n        // instead of the current privilege level (code access is unaffected)\\n        //TO-DO: Check this &/&& and shifts\\n        if ((uint64vars[MSTATUS] & RiscVConstants.getMstatusMprvMask() != 0) && (xwrShift != RiscVConstants.getPteXwrCodeShift())) {\\n            intvars[PRIV] = (uint64vars[MSTATUS] & RiscVConstants.getMstatusMppMask()) >> RiscVConstants.getMstatusMppShift();\\n        }\\n\\n        // Physical memory is mediated by Machine-mode so, if privilege is M-mode it\\n        // does not use virtual Memory\\n        // Reference: riscv-priv-spec-1.7.pdf - Section 3.3, page 32.\\n        if (intvars[PRIV] == RiscVConstants.getPrvM()) {\\n            return (true, vaddr);\\n        }\\n\\n        // SATP - Supervisor Address Translation and Protection Register\\n        // Holds MODE, Physical page number (PPN) and address space identifier (ASID)\\n        // MODE is located on bits 60 to 63 for RV64.\\n        // Reference: riscv-priv-spec-1.10.pdf - Section 4.1.12, page 56.\\n        uint64vars[SATP] = mi.memoryRead(ShadowAddresses.getSatp());\\n        // In RV64, mode can be\\n        //   0: Bare: No translation or protection\\n        //   8: sv39: Page-based 39-bit virtual addressing\\n        //   9: sv48: Page-based 48-bit virtual addressing\\n        // Reference: riscv-priv-spec-1.10.pdf - Table 4.3, page 57.\\n        intvars[MODE] = (uint64vars[SATP] >> 60) & 0xf;\\n\\n        if (intvars[MODE] == 0) {\\n            return(true, vaddr);\\n        } else if (intvars[MODE] < 8 || intvars[MODE] > 9) {\\n            return(false, 0);\\n        }\\n        // Here we know we are in sv39 or sv48 modes\\n\\n        // Page table hierarchy of sv39 has 3 levels, and sv48 has 4 levels\\n        int levels = intvars[MODE] - 8 + 3;\\n        // Page offset are bits located from 0 to 11.\\n        // Then come levels virtual page numbers (VPN)\\n        // The rest of vaddr must be filled with copies of the\\n        // most significant bit in VPN[levels]\\n        // Hence, the use of arithmetic shifts here\\n        // Reference: riscv-priv-spec-1.10.pdf - Figure 4.16, page 63.\\n\\n        //TO-DO: Use bitmanipulation library for arithmetic shift\\n        intvars[VADDR_SHIFT] = RiscVConstants.getXlen() - (RiscVConstants.getPgShift() + levels * 9);\\n        if (((int64(vaddr) << uint64(intvars[VADDR_SHIFT])) >> uint64(intvars[VADDR_SHIFT])) != int64(vaddr)) {\\n            return (false, 0);\\n        }\\n        // The least significant 44 bits of satp contain the physical page number\\n        // for the root page table\\n        // Reference: riscv-priv-spec-1.10.pdf - Figure 4.12, page 57.\\n        intvars[SATP_PPN_BITS] = 44;\\n        // Initialize pteAddr with the base address for the root page table\\n        uint64vars[PTE_ADDR] = (uint64vars[SATP] & ((uint64(1) << uint64(intvars[SATP_PPN_BITS])) - 1)) << RiscVConstants.getPgShift();\\n        // All page table entries have 8 bytes\\n        // Each page table has 4k/pteSize entries\\n        // To index all entries, we need vpnBits\\n        // Reference: riscv-priv-spec-1.10.pdf - Section 4.4.1, page 63.\\n        intvars[PTE_SIZE_LOG2] = 3;\\n        intvars[VPN_BITS] = 12 - intvars[PTE_SIZE_LOG2];\\n        uint64vars[VPN_MASK] = uint64((1 << uint(intvars[VPN_BITS])) - 1);\\n\\n        for (int i = 0; i < levels; i++) {\\n            // Mask out VPN[levels -i-1]\\n            intvars[VADDR_SHIFT] = RiscVConstants.getPgShift() + intvars[VPN_BITS] * (levels - 1 - i);\\n            uint64 vpn = (vaddr >> uint(intvars[VADDR_SHIFT])) & uint64vars[VPN_MASK];\\n            // Add offset to find physical address of page table entry\\n            uint64vars[PTE_ADDR] += vpn << uint64(intvars[PTE_SIZE_LOG2]);\\n            //Read page table entry from physical memory\\n            bool readRamSucc;\\n            (readRamSucc, uint64vars[PTE]) = readRamUint64(mi, uint64vars[PTE_ADDR]);\\n\\n            if (!readRamSucc) {\\n                return(false, 0);\\n            }\\n\\n            // The OS can mark page table entries as invalid,\\n            // but these entries shouldn't be reached during page lookups\\n            //TO-DO: check if condition\\n            if ((uint64vars[PTE] & RiscVConstants.getPteVMask()) == 0) {\\n                return (false, 0);\\n            }\\n            // Clear all flags in least significant bits, then shift back to multiple of page size to form physical address\\n            uint64 ppn = (uint64vars[PTE] >> 10) << RiscVConstants.getPgShift();\\n            // Obtain X, W, R protection bits\\n            // X, W, R bits are located on bits 1 to 3 on physical address\\n            // Reference: riscv-priv-spec-1.10.pdf - Figure 4.18, page 63.\\n            int xwr = (uint64vars[PTE] >> 1) & 7;\\n            // xwr !=0 means we are done walking the page tables\\n            if (xwr != 0) {\\n                // These protection bit combinations are reserved for future use\\n                if (xwr == 2 || xwr == 6) {\\n                    return (false, 0);\\n                }\\n                // (We know we are not PRV_M if we reached here)\\n                if (intvars[PRIV] == RiscVConstants.getPrvS()) {\\n                    // If SUM is set, forbid S-mode code from accessing U-mode memory\\n                    //TO-DO: check if condition\\n                    if ((uint64vars[PTE] & RiscVConstants.getPteUMask() != 0) && ((uint64vars[MSTATUS] & RiscVConstants.getMstatusSumMask())) == 0) {\\n                        return (false, 0);\\n                    }\\n                } else {\\n                    // Forbid U-mode code from accessing S-mode memory\\n                    if ((uint64vars[PTE] & RiscVConstants.getPteUMask()) == 0) {\\n                        return (false, 0);\\n                    }\\n                }\\n                // MXR allows to read access to execute-only pages\\n                if (uint64vars[MSTATUS] & RiscVConstants.getMstatusMxrMask() != 0) {\\n                    //Set R bit if X bit is set\\n                    xwr = xwr | (xwr >> 2);\\n                }\\n                // Check protection bits against request access\\n                if (((xwr >> uint(xwrShift)) & 1) == 0) {\\n                    return (false, 0);\\n                }\\n                // Check page, megapage, and gigapage alignment\\n                uint64vars[VADDR_MASK] = (uint64(1) << uint64(intvars[VADDR_SHIFT])) - 1;\\n                if (ppn & uint64vars[VADDR_MASK] != 0) {\\n                    return (false, 0);\\n                }\\n                // Decide if we need to update access bits in pte\\n                bool updatePte = (uint64vars[PTE] & RiscVConstants.getPteAMask() == 0) || ((uint64vars[PTE] & RiscVConstants.getPteDMask() == 0) && xwrShift == RiscVConstants.getPteXwrWriteShift());\\n\\n                uint64vars[PTE] |= RiscVConstants.getPteAMask();\\n\\n                if (xwrShift == RiscVConstants.getPteXwrWriteShift()) {\\n                    uint64vars[PTE] = uint64vars[PTE] | RiscVConstants.getPteDMask();\\n                }\\n                // If so, update pte\\n                if (updatePte) {\\n                    writeRamUint64(\\n                        mi,\\n                        uint64vars[PTE_ADDR],\\n                        uint64vars[PTE]\\n                    );\\n                }\\n                // Add page offset in vaddr to ppn to form physical address\\n                return (true, (vaddr & uint64vars[VADDR_MASK]) | (ppn & ~uint64vars[VADDR_MASK]));\\n            }else {\\n                uint64vars[PTE_ADDR] = ppn;\\n            }\\n        }\\n        return (false, 0);\\n    }\\n\\n    function readRamUint64(MemoryInteractor mi, uint64 paddr)\\n    internal returns (bool, uint64)\\n    {\\n        uint64 pmaStart = PMA.findPmaEntry(mi, paddr);\\n        if (!PMA.pmaGetIstartM(pmaStart) || !PMA.pmaGetIstartR(pmaStart)) {\\n            return (false, 0);\\n        }\\n        return (true, mi.readMemory(paddr, 64));\\n    }\\n\\n    function writeRamUint64(\\n        MemoryInteractor mi,\\n        uint64 paddr,\\n        uint64 val\\n    )\\n    internal returns (bool)\\n    {\\n        uint64 pmaStart = PMA.findPmaEntry(mi, paddr);\\n        if (!PMA.pmaGetIstartM(pmaStart) || !PMA.pmaGetIstartW(pmaStart)) {\\n            return false;\\n        }\\n        mi.writeMemory(\\n            paddr,\\n            val,\\n            64\\n        );\\n        return true;\\n    }\\n\\n}\\n\",\"keccak256\":\"0xf31e6be1dd768fec368c09b3f47fa44c58ad237255ef8cb6bae8dbc770d68e6f\",\"license\":\"Apache-2.0\"}},\"version\":1}",
  "bytecode": "0x612a0c610026600b82828239805160001a60731461001957fe5b30600052607381538281f3fe730000000000000000000000000000000000000000301460806040526004361061004b5760003560e01c806323b9cae914610050578063593706cd146100bd578063ef8fc22f14610125575b600080fd5b81801561005c57600080fd5b5061009a6004803603606081101561007357600080fd5b506001600160a01b03813516906001600160401b036020820135811691604001351661016d565b6040805192151583526001600160401b0390911660208301528051918290030190f35b8180156100c957600080fd5b50610111600480360360808110156100e057600080fd5b506001600160a01b03813516906001600160401b036020820135811691604081013582169160609091013516610b23565b604080519115158252519081900360200190f35b81801561013157600080fd5b5061009a6004803603606081101561014857600080fd5b506001600160a01b03813516906001600160401b03602082013516906040013561146f565b6000806101786129b8565b600160086001600160401b038716040384166001600160401b03166000146102a75773A404230965BB7E08F29732B3A38F001d6C28e0E2630b2c70098773A404230965BB7E08F29732B3A38F001d6C28e0E263f4a407616040518163ffffffff1660e01b815260040160206040518083038186803b1580156101f957600080fd5b505af415801561020d573d6000803e3d6000fd5b505050506040513d602081101561022357600080fd5b5051604080516001600160e01b031960e086901b1681526001600160a01b0390931660048401526001600160401b0391821660248401529088166044830152516064808301926000929190829003018186803b15801561028257600080fd5b505af4158015610296573d6000803e3d6000fd5b505050506000809250925050610b1b565b60008061032d88877308367820CD9849A6FA6964c7cEf53C5C47fA5C08637df413636040518163ffffffff1660e01b815260040160206040518083038186803b1580156102f357600080fd5b505af4158015610307573d6000803e3d6000fd5b505050506040513d602081101561031d57600080fd5b50516001600160401b031661146f565b91509150816104455773A404230965BB7E08F29732B3A38F001d6C28e0E2630b2c70098973A404230965BB7E08F29732B3A38F001d6C28e0E263403917746040518163ffffffff1660e01b815260040160206040518083038186803b15801561039557600080fd5b505af41580156103a9573d6000803e3d6000fd5b505050506040513d60208110156103bf57600080fd5b5051604080516001600160e01b031960e086901b1681526001600160a01b0390931660048401526001600160401b039182166024840152908a166044830152516064808301926000929190829003018186803b15801561041e57600080fd5b505af4158015610432573d6000803e3d6000fd5b5050505060008094509450505050610b1b565b6040805163da19616360e01b81526001600160a01b038a1660048201526001600160401b03831660248201529051732EaeBb94FFA7FF7d08CF33c46681D3831e04a1849163da196163916044808301926020929190829003018186803b1580156104ae57600080fd5b505af41580156104c2573d6000803e3d6000fd5b505050506040513d60208110156104d857600080fd5b50516001600160401b03166020808501829052604080516331fe49e960e01b8152600481019390935251732EaeBb94FFA7FF7d08CF33c46681D3831e04a184926331fe49e9926024808301939192829003018186803b15801561053a57600080fd5b505af415801561054e573d6000803e3d6000fd5b505050506040513d602081101561056457600080fd5b5051806105f6575060208084015160408051631d2f5b5b60e01b81526001600160401b03909216600483015251732EaeBb94FFA7FF7d08CF33c46681D3831e04a18492631d2f5b5b9260248082019391829003018186803b1580156105c857600080fd5b505af41580156105dc573d6000803e3d6000fd5b505050506040513d60208110156105f257600080fd5b5051155b1561065a5773A404230965BB7E08F29732B3A38F001d6C28e0E2630b2c70098973A404230965BB7E08F29732B3A38F001d6C28e0E263012984046040518163ffffffff1660e01b815260040160206040518083038186803b15801561039557600080fd5b60208084015160408051632d2cffe160e21b81526001600160401b03909216600483015251732EaeBb94FFA7FF7d08CF33c46681D3831e04a1849263b4b3ff849260248082019391829003018186803b1580156106b657600080fd5b505af41580156106ca573d6000803e3d6000fd5b505050506040513d60208110156106e057600080fd5b505115610783576001886001600160a01b03166350cec2d5838a6040518363ffffffff1660e01b815260040180836001600160401b03168152602001826001600160401b0316815260200192505050602060405180830381600087803b15801561074957600080fd5b505af115801561075d573d6000803e3d6000fd5b505050506040513d602081101561077357600080fd5b50519095509350610b1b92505050565b60208084015160408051631fb4b3d360e01b81526001600160401b03909216600483015251600092732EaeBb94FFA7FF7d08CF33c46681D3831e04a18492631fb4b3d39260248083019392829003018186803b1580156107e257600080fd5b505af41580156107f6573d6000803e3d6000fd5b505050506040513d602081101561080c57600080fd5b5051156108c857604080516301a8b9f960e11b81526001600160a01b038b1660048201526001600160401b0380851660248301528a166044820152815173fdFF3De6C36305319d756455843963080f38cb429263035173f29260648082019391829003018186803b15801561088057600080fd5b505af4158015610894573d6000803e3d6000fd5b505050506040513d60408110156108aa57600080fd5b5080516020909101516001600160401b031660608601529050610a06565b6020808501516040805163aa7332a960e01b81526001600160401b03909216600483015251732EaeBb94FFA7FF7d08CF33c46681D3831e04a1849263aa7332a99260248082019391829003018186803b15801561092457600080fd5b505af4158015610938573d6000803e3d6000fd5b505050506040513d602081101561094e57600080fd5b505115610a06576040805163e1e9c4a560e01b81526001600160a01b038b1660048201526001600160401b0380851660248301528a166044820152815173BaDC34c0fc1233b68a4a486C227C495f82Be5eB69263e1e9c4a59260648082019391829003018186803b1580156109c257600080fd5b505af41580156109d6573d6000803e3d6000fd5b505050506040513d60408110156109ec57600080fd5b5080516020909101516001600160401b0316606086015290505b80610b0c5773A404230965BB7E08F29732B3A38F001d6C28e0E2630b2c70098a73A404230965BB7E08F29732B3A38F001d6C28e0E263012984046040518163ffffffff1660e01b815260040160206040518083038186803b158015610a6a57600080fd5b505af4158015610a7e573d6000803e3d6000fd5b505050506040513d6020811015610a9457600080fd5b5051604080516001600160e01b031960e086901b1681526001600160a01b0390931660048401526001600160401b039182166024840152908b166044830152516064808301926000929190829003018186803b158015610af357600080fd5b505af4158015610b07573d6000803e3d6000fd5b505050505b60609093015192945091925050505b935093915050565b6000610b2d6129b8565b600160086001600160401b038716040384166001600160401b0316600014610c595773A404230965BB7E08F29732B3A38F001d6C28e0E2630b2c70098773A404230965BB7E08F29732B3A38F001d6C28e0E263d8685e086040518163ffffffff1660e01b815260040160206040518083038186803b158015610bae57600080fd5b505af4158015610bc2573d6000803e3d6000fd5b505050506040513d6020811015610bd857600080fd5b5051604080516001600160e01b031960e086901b1681526001600160a01b0390931660048401526001600160401b0391821660248401529088166044830152516064808301926000929190829003018186803b158015610c3757600080fd5b505af4158015610c4b573d6000803e3d6000fd5b505050506000915050611467565b6000610ca487867308367820CD9849A6FA6964c7cEf53C5C47fA5C0863b0c41fc56040518163ffffffff1660e01b815260040160206040518083038186803b1580156102f357600080fd5b6001600160401b03166040840152905080610dc45773A404230965BB7E08F29732B3A38F001d6C28e0E2630b2c70098873A404230965BB7E08F29732B3A38F001d6C28e0E263a4652fa56040518163ffffffff1660e01b815260040160206040518083038186803b158015610d1857600080fd5b505af4158015610d2c573d6000803e3d6000fd5b505050506040513d6020811015610d4257600080fd5b5051604080516001600160e01b031960e086901b1681526001600160a01b0390931660048401526001600160401b0391821660248401529089166044830152516064808301926000929190829003018186803b158015610da157600080fd5b505af4158015610db5573d6000803e3d6000fd5b50505050600092505050611467565b604080830151815163da19616360e01b81526001600160a01b038a1660048201526001600160401b0390911660248201529051732EaeBb94FFA7FF7d08CF33c46681D3831e04a1849163da196163916044808301926020929190829003018186803b158015610e3257600080fd5b505af4158015610e46573d6000803e3d6000fd5b505050506040513d6020811015610e5c57600080fd5b50516001600160401b03166020808401829052604080516331fe49e960e01b8152600481019390935251732EaeBb94FFA7FF7d08CF33c46681D3831e04a184926331fe49e9926024808301939192829003018186803b158015610ebe57600080fd5b505af4158015610ed2573d6000803e3d6000fd5b505050506040513d6020811015610ee857600080fd5b505180610f7a575060208083015160408051631956c73d60e01b81526001600160401b03909216600483015251732EaeBb94FFA7FF7d08CF33c46681D3831e04a18492631956c73d9260248082019391829003018186803b158015610f4c57600080fd5b505af4158015610f60573d6000803e3d6000fd5b505050506040513d6020811015610f7657600080fd5b5051155b15610fde5773A404230965BB7E08F29732B3A38F001d6C28e0E2630b2c70098873A404230965BB7E08F29732B3A38F001d6C28e0E26348b36c3a6040518163ffffffff1660e01b815260040160206040518083038186803b158015610d1857600080fd5b60208083015160408051632d2cffe160e21b81526001600160401b03909216600483015251732EaeBb94FFA7FF7d08CF33c46681D3831e04a1849263b4b3ff849260248082019391829003018186803b15801561103a57600080fd5b505af415801561104e573d6000803e3d6000fd5b505050506040513d602081101561106457600080fd5b5051156110f3576040808301518151637e94ad5f60e11b81526001600160401b0391821660048201528187166024820152908816604482015290516001600160a01b0389169163fd295abe91606480830192600092919082900301818387803b1580156110d057600080fd5b505af11580156110e4573d6000803e3d6000fd5b50505050600192505050611467565b60208083015160408051631fb4b3d360e01b81526001600160401b03909216600483015251732EaeBb94FFA7FF7d08CF33c46681D3831e04a18492631fb4b3d39260248082019391829003018186803b15801561114f57600080fd5b505af4158015611163573d6000803e3d6000fd5b505050506040513d602081101561117957600080fd5b5051156112af5773fdFF3De6C36305319d756455843963080f38cb426391b78523886111ac8560015b6020020151612513565b878a6040518563ffffffff1660e01b815260040180856001600160a01b03168152602001846001600160401b03168152602001836001600160401b03168152602001826001600160401b0316815260200194505050505060206040518083038186803b15801561121b57600080fd5b505af415801561122f573d6000803e3d6000fd5b505050506040513d602081101561124557600080fd5b50516112aa5773A404230965BB7E08F29732B3A38F001d6C28e0E2630b2c70098873A404230965BB7E08F29732B3A38F001d6C28e0E26348b36c3a6040518163ffffffff1660e01b815260040160206040518083038186803b158015610d1857600080fd5b611460565b6020808301516040805163aa7332a960e01b81526001600160401b03909216600483015251732EaeBb94FFA7FF7d08CF33c46681D3831e04a1849263aa7332a99260248082019391829003018186803b15801561130b57600080fd5b505af415801561131f573d6000803e3d6000fd5b505050506040513d602081101561133557600080fd5b5051156114605773BaDC34c0fc1233b68a4a486C227C495f82Be5eB66362cba9aa886113628560016111a2565b878a6040518563ffffffff1660e01b815260040180856001600160a01b03168152602001846001600160401b03168152602001836001600160401b03168152602001826001600160401b0316815260200194505050505060206040518083038186803b1580156113d157600080fd5b505af41580156113e5573d6000803e3d6000fd5b505050506040513d60208110156113fb57600080fd5b50516114605773A404230965BB7E08F29732B3A38F001d6C28e0E2630b2c70098873A404230965BB7E08F29732B3A38F001d6C28e0E26348b36c3a6040518163ffffffff1660e01b815260040160206040518083038186803b158015610d1857600080fd5b6001925050505b949350505050565b60008061147a6129b8565b6114826129b8565b866001600160a01b031663f7ac913d6040518163ffffffff1660e01b8152600401602060405180830381600087803b1580156114bd57600080fd5b505af11580156114d1573d6000803e3d6000fd5b505050506040513d60208110156114e757600080fd5b50516001600160401b0316816000602002018181525050866001600160a01b031663fa644af5734D7479bF76387f35D84B9f1BE586Aa83d91182946342db36676040518163ffffffff1660e01b815260040160206040518083038186803b15801561155157600080fd5b505af4158015611565573d6000803e3d6000fd5b505050506040513d602081101561157b57600080fd5b5051604080516001600160e01b031960e085901b1681526001600160401b0390921660048301525160248083019260209291908290030181600087803b1580156115c457600080fd5b505af11580156115d8573d6000803e3d6000fd5b505050506040513d60208110156115ee57600080fd5b50516001600160401b03166040808401919091528051638c295e3560e01b815290517308367820CD9849A6FA6964c7cEf53C5C47fA5C0891638c295e35916004808301926020929190829003018186803b15801561164b57600080fd5b505af415801561165f573d6000803e3d6000fd5b505050506040513d602081101561167557600080fd5b50516040830151166001600160401b03161580159061170c57507308367820CD9849A6FA6964c7cEf53C5C47fA5C0863bc8957436040518163ffffffff1660e01b815260040160206040518083038186803b1580156116d357600080fd5b505af41580156116e7573d6000803e3d6000fd5b505050506040513d60208110156116fd57600080fd5b50516001600160401b03168514155b1561181c577308367820CD9849A6FA6964c7cEf53C5C47fA5C0863a16de11c6040518163ffffffff1660e01b815260040160206040518083038186803b15801561175557600080fd5b505af4158015611769573d6000803e3d6000fd5b505050506040513d602081101561177f57600080fd5b5051604080516373a3563960e11b815290516001600160401b03909216917308367820CD9849A6FA6964c7cEf53C5C47fA5C089163e746ac72916004808301926020929190829003018186803b1580156117d857600080fd5b505af41580156117ec573d6000803e3d6000fd5b505050506040513d602081101561180257600080fd5b50516040840151166001600160401b0390811690911c1681525b7308367820CD9849A6FA6964c7cEf53C5C47fA5C0863cf7ecf796040518163ffffffff1660e01b815260040160206040518083038186803b15801561186057600080fd5b505af4158015611874573d6000803e3d6000fd5b505050506040513d602081101561188a57600080fd5b505181516001600160401b0390911614156118ad57600186935093505050610b1b565b866001600160a01b031663fa644af5734D7479bF76387f35D84B9f1BE586Aa83d911829463443fd5986040518163ffffffff1660e01b815260040160206040518083038186803b15801561190057600080fd5b505af4158015611914573d6000803e3d6000fd5b505050506040513d602081101561192a57600080fd5b5051604080516001600160e01b031960e085901b1681526001600160401b0390921660048301525160248083019260209291908290030181600087803b15801561197357600080fd5b505af1158015611987573d6000803e3d6000fd5b505050506040513d602081101561199d57600080fd5b50516001600160401b0381166060840152603c1c600f16602082018190526119cd57600186935093505050610b1b565b6020810151600813806119e4575060208101516009125b156119f757600080935093505050610b1b565b600060088260016020020151036003019050806009027308367820CD9849A6FA6964c7cEf53C5C47fA5C0863a1a290056040518163ffffffff1660e01b815260040160206040518083038186803b158015611a5157600080fd5b505af4158015611a65573d6000803e3d6000fd5b505050506040513d6020811015611a7b57600080fd5b505160408051635a72a4dd60e11b815290516001600160401b0390921692909201917308367820CD9849A6FA6964c7cEf53C5C47fA5C089163b4e549ba91600480820192602092909190829003018186803b158015611ad957600080fd5b505af4158015611aed573d6000803e3d6000fd5b505050506040513d6020811015611b0357600080fd5b50516001600160401b039081169190910360408401819052600789810b9190921681811b830b901d90910b14611b425760008094509450505050610b1b565b602c8260056020020181815250507308367820CD9849A6FA6964c7cEf53C5C47fA5C0863a1a290056040518163ffffffff1660e01b815260040160206040518083038186803b158015611b9457600080fd5b505af4158015611ba8573d6000803e3d6000fd5b505050506040513d6020811015611bbe57600080fd5b505160a083015160608086015160001960016001600160401b039485161b011682169282169290921b16602085015260039083015260096080808401919091526101ff9084015260005b8181121561250257808203600019018360046020020151027308367820CD9849A6FA6964c7cEf53C5C47fA5C0863a1a290056040518163ffffffff1660e01b815260040160206040518083038186803b158015611c6457600080fd5b505af4158015611c78573d6000803e3d6000fd5b505050506040513d6020811015611c8e57600080fd5b50516001600160401b039081169190910160408501819052608086015160608601516020880180518d861690941c9092168085169185169190911b9092019092169182905290600090611ce2908c90612520565b6001600160401b031660a0880152905080611d095760008097509750505050505050610b1b565b7308367820CD9849A6FA6964c7cEf53C5C47fA5C0863574a20ef6040518163ffffffff1660e01b815260040160206040518083038186803b158015611d4d57600080fd5b505af4158015611d61573d6000803e3d6000fd5b505050506040513d6020811015611d7757600080fd5b505160a0870151166001600160401b0316611d9e5760008097509750505050505050610b1b565b60007308367820CD9849A6FA6964c7cEf53C5C47fA5C0863a1a290056040518163ffffffff1660e01b815260040160206040518083038186803b158015611de457600080fd5b505af4158015611df8573d6000803e3d6000fd5b505050506040513d6020811015611e0e57600080fd5b505160a0880151600a81901c663fffffffffffff166001600160401b039092169190911b915060011c60071680156124e9578060021480611e4f5750806006145b15611e6857600080995099505050505050505050610b1b565b7308367820CD9849A6FA6964c7cEf53C5C47fA5C0863026797d96040518163ffffffff1660e01b815260040160206040518083038186803b158015611eac57600080fd5b505af4158015611ec0573d6000803e3d6000fd5b505050506040513d6020811015611ed657600080fd5b505187516001600160401b039091161415612012577308367820CD9849A6FA6964c7cEf53C5C47fA5C0863a4521d8b6040518163ffffffff1660e01b815260040160206040518083038186803b158015611f2f57600080fd5b505af4158015611f43573d6000803e3d6000fd5b505050506040513d6020811015611f5957600080fd5b505160a0890151166001600160401b031615801590611ff457507308367820CD9849A6FA6964c7cEf53C5C47fA5C08638a17ca866040518163ffffffff1660e01b815260040160206040518083038186803b158015611fb757600080fd5b505af4158015611fcb573d6000803e3d6000fd5b505050506040513d6020811015611fe157600080fd5b50516040890151166001600160401b0316155b1561200d57600080995099505050505050505050610b1b565b6120a9565b7308367820CD9849A6FA6964c7cEf53C5C47fA5C0863a4521d8b6040518163ffffffff1660e01b815260040160206040518083038186803b15801561205657600080fd5b505af415801561206a573d6000803e3d6000fd5b505050506040513d602081101561208057600080fd5b505160a0890151166001600160401b03166120a957600080995099505050505050505050610b1b565b7308367820CD9849A6FA6964c7cEf53C5C47fA5C08634e95a4106040518163ffffffff1660e01b815260040160206040518083038186803b1580156120ed57600080fd5b505af4158015612101573d6000803e3d6000fd5b505050506040513d602081101561211757600080fd5b50516040890151166001600160401b03161561213457600281901d175b6001818c1d1661215257600080995099505050505050505050610b1b565b604087015160001960016001600160401b039283161b018082168a528316161561218a57600080995099505050505050505050610b1b565b60007308367820CD9849A6FA6964c7cEf53C5C47fA5C0863501bec456040518163ffffffff1660e01b815260040160206040518083038186803b1580156121d057600080fd5b505af41580156121e4573d6000803e3d6000fd5b505050506040513d60208110156121fa57600080fd5b505160a08a0151166001600160401b0316158061231557507308367820CD9849A6FA6964c7cEf53C5C47fA5C08633fe2098a6040518163ffffffff1660e01b815260040160206040518083038186803b15801561225657600080fd5b505af415801561226a573d6000803e3d6000fd5b505050506040513d602081101561228057600080fd5b505160a08a0151166001600160401b031615801561231557507308367820CD9849A6FA6964c7cEf53C5C47fA5C0863b0c41fc56040518163ffffffff1660e01b815260040160206040518083038186803b1580156122dd57600080fd5b505af41580156122f1573d6000803e3d6000fd5b505050506040513d602081101561230757600080fd5b50516001600160401b03168c145b90507308367820CD9849A6FA6964c7cEf53C5C47fA5C0863501bec456040518163ffffffff1660e01b815260040160206040518083038186803b15801561235b57600080fd5b505af415801561236f573d6000803e3d6000fd5b505050506040513d602081101561238557600080fd5b505160a08a0180519091176001600160401b031690526040805163b0c41fc560e01b815290517308367820CD9849A6FA6964c7cEf53C5C47fA5C089163b0c41fc5916004808301926020929190829003018186803b1580156123e657600080fd5b505af41580156123fa573d6000803e3d6000fd5b505050506040513d602081101561241057600080fd5b50516001600160401b03168c14156124a7577308367820CD9849A6FA6964c7cEf53C5C47fA5C08633fe2098a6040518163ffffffff1660e01b815260040160206040518083038186803b15801561246657600080fd5b505af415801561247a573d6000803e3d6000fd5b505050506040513d602081101561249057600080fd5b505160a08a0180519091176001600160401b031690525b80156124c8576124c68e8a600160200201518b60056020020151612776565b505b50509551600198508019909616958a16959095179550610b1b945050505050565b506001600160401b031660208701525050600101611c08565b506000988998509650505050505050565b67fffffffffffff0001690565b6000806000732EaeBb94FFA7FF7d08CF33c46681D3831e04a18463da19616386866040518363ffffffff1660e01b815260040180836001600160a01b03168152602001826001600160401b031681526020019250505060206040518083038186803b15801561258e57600080fd5b505af41580156125a2573d6000803e3d6000fd5b505050506040513d60208110156125b857600080fd5b505160408051632d2cffe160e21b81526001600160401b03831660048201529051919250732EaeBb94FFA7FF7d08CF33c46681D3831e04a1849163b4b3ff8491602480820192602092909190829003018186803b15801561261857600080fd5b505af415801561262c573d6000803e3d6000fd5b505050506040513d602081101561264257600080fd5b505115806126d15750732EaeBb94FFA7FF7d08CF33c46681D3831e04a184631d2f5b5b826040518263ffffffff1660e01b815260040180826001600160401b0316815260200191505060206040518083038186803b1580156126a357600080fd5b505af41580156126b7573d6000803e3d6000fd5b505050506040513d60208110156126cd57600080fd5b5051155b156126e357600080925092505061276f565b6001856001600160a01b03166350cec2d586604080518363ffffffff1660e01b815260040180836001600160401b0316815260200182815260200192505050602060405180830381600087803b15801561273c57600080fd5b505af1158015612750573d6000803e3d6000fd5b505050506040513d602081101561276657600080fd5b50519093509150505b9250929050565b600080732EaeBb94FFA7FF7d08CF33c46681D3831e04a18463da19616386866040518363ffffffff1660e01b815260040180836001600160a01b03168152602001826001600160401b031681526020019250505060206040518083038186803b1580156127e257600080fd5b505af41580156127f6573d6000803e3d6000fd5b505050506040513d602081101561280c57600080fd5b505160408051632d2cffe160e21b81526001600160401b03831660048201529051919250732EaeBb94FFA7FF7d08CF33c46681D3831e04a1849163b4b3ff8491602480820192602092909190829003018186803b15801561286c57600080fd5b505af4158015612880573d6000803e3d6000fd5b505050506040513d602081101561289657600080fd5b505115806129255750732EaeBb94FFA7FF7d08CF33c46681D3831e04a184631956c73d826040518263ffffffff1660e01b815260040180826001600160401b0316815260200191505060206040518083038186803b1580156128f757600080fd5b505af415801561290b573d6000803e3d6000fd5b505050506040513d602081101561292157600080fd5b5051155b156129345760009150506129b1565b60408051637e94ad5f60e11b81526001600160401b038087166004830152851660248201526044810182905290516001600160a01b0387169163fd295abe91606480830192600092919082900301818387803b15801561299357600080fd5b505af11580156129a7573d6000803e3d6000fd5b5050505060019150505b9392505050565b6040518060c00160405280600690602082028036833750919291505056fea2646970667358221220726e3caab2cc2283ea73db95d9d97c11de0fa9ddee63f282d9a5585d2143093564736f6c63430007040033",
  "deployedBytecode": "0x730000000000000000000000000000000000000000301460806040526004361061004b5760003560e01c806323b9cae914610050578063593706cd146100bd578063ef8fc22f14610125575b600080fd5b81801561005c57600080fd5b5061009a6004803603606081101561007357600080fd5b506001600160a01b03813516906001600160401b036020820135811691604001351661016d565b6040805192151583526001600160401b0390911660208301528051918290030190f35b8180156100c957600080fd5b50610111600480360360808110156100e057600080fd5b506001600160a01b03813516906001600160401b036020820135811691604081013582169160609091013516610b23565b604080519115158252519081900360200190f35b81801561013157600080fd5b5061009a6004803603606081101561014857600080fd5b506001600160a01b03813516906001600160401b03602082013516906040013561146f565b6000806101786129b8565b600160086001600160401b038716040384166001600160401b03166000146102a75773__$7a619e2484503bc317a624d2cc621a55c4$__630b2c70098773__$7a619e2484503bc317a624d2cc621a55c4$__63f4a407616040518163ffffffff1660e01b815260040160206040518083038186803b1580156101f957600080fd5b505af415801561020d573d6000803e3d6000fd5b505050506040513d602081101561022357600080fd5b5051604080516001600160e01b031960e086901b1681526001600160a01b0390931660048401526001600160401b0391821660248401529088166044830152516064808301926000929190829003018186803b15801561028257600080fd5b505af4158015610296573d6000803e3d6000fd5b505050506000809250925050610b1b565b60008061032d888773__$6af7953b03ecb3cadd1ca9bb3675b9b8d6$__637df413636040518163ffffffff1660e01b815260040160206040518083038186803b1580156102f357600080fd5b505af4158015610307573d6000803e3d6000fd5b505050506040513d602081101561031d57600080fd5b50516001600160401b031661146f565b91509150816104455773__$7a619e2484503bc317a624d2cc621a55c4$__630b2c70098973__$7a619e2484503bc317a624d2cc621a55c4$__63403917746040518163ffffffff1660e01b815260040160206040518083038186803b15801561039557600080fd5b505af41580156103a9573d6000803e3d6000fd5b505050506040513d60208110156103bf57600080fd5b5051604080516001600160e01b031960e086901b1681526001600160a01b0390931660048401526001600160401b039182166024840152908a166044830152516064808301926000929190829003018186803b15801561041e57600080fd5b505af4158015610432573d6000803e3d6000fd5b5050505060008094509450505050610b1b565b6040805163da19616360e01b81526001600160a01b038a1660048201526001600160401b0383166024820152905173__$ab3fd86e507257b3ab9832a7c6180fb495$__9163da196163916044808301926020929190829003018186803b1580156104ae57600080fd5b505af41580156104c2573d6000803e3d6000fd5b505050506040513d60208110156104d857600080fd5b50516001600160401b03166020808501829052604080516331fe49e960e01b815260048101939093525173__$ab3fd86e507257b3ab9832a7c6180fb495$__926331fe49e9926024808301939192829003018186803b15801561053a57600080fd5b505af415801561054e573d6000803e3d6000fd5b505050506040513d602081101561056457600080fd5b5051806105f6575060208084015160408051631d2f5b5b60e01b81526001600160401b0390921660048301525173__$ab3fd86e507257b3ab9832a7c6180fb495$__92631d2f5b5b9260248082019391829003018186803b1580156105c857600080fd5b505af41580156105dc573d6000803e3d6000fd5b505050506040513d60208110156105f257600080fd5b5051155b1561065a5773__$7a619e2484503bc317a624d2cc621a55c4$__630b2c70098973__$7a619e2484503bc317a624d2cc621a55c4$__63012984046040518163ffffffff1660e01b815260040160206040518083038186803b15801561039557600080fd5b60208084015160408051632d2cffe160e21b81526001600160401b0390921660048301525173__$ab3fd86e507257b3ab9832a7c6180fb495$__9263b4b3ff849260248082019391829003018186803b1580156106b657600080fd5b505af41580156106ca573d6000803e3d6000fd5b505050506040513d60208110156106e057600080fd5b505115610783576001886001600160a01b03166350cec2d5838a6040518363ffffffff1660e01b815260040180836001600160401b03168152602001826001600160401b0316815260200192505050602060405180830381600087803b15801561074957600080fd5b505af115801561075d573d6000803e3d6000fd5b505050506040513d602081101561077357600080fd5b50519095509350610b1b92505050565b60208084015160408051631fb4b3d360e01b81526001600160401b0390921660048301525160009273__$ab3fd86e507257b3ab9832a7c6180fb495$__92631fb4b3d39260248083019392829003018186803b1580156107e257600080fd5b505af41580156107f6573d6000803e3d6000fd5b505050506040513d602081101561080c57600080fd5b5051156108c857604080516301a8b9f960e11b81526001600160a01b038b1660048201526001600160401b0380851660248301528a166044820152815173__$96c0387300a4d16af366df01fc33f52e50$__9263035173f29260648082019391829003018186803b15801561088057600080fd5b505af4158015610894573d6000803e3d6000fd5b505050506040513d60408110156108aa57600080fd5b5080516020909101516001600160401b031660608601529050610a06565b6020808501516040805163aa7332a960e01b81526001600160401b0390921660048301525173__$ab3fd86e507257b3ab9832a7c6180fb495$__9263aa7332a99260248082019391829003018186803b15801561092457600080fd5b505af4158015610938573d6000803e3d6000fd5b505050506040513d602081101561094e57600080fd5b505115610a06576040805163e1e9c4a560e01b81526001600160a01b038b1660048201526001600160401b0380851660248301528a166044820152815173__$3c056aa8a31fb3ce78f242f7ef99e26695$__9263e1e9c4a59260648082019391829003018186803b1580156109c257600080fd5b505af41580156109d6573d6000803e3d6000fd5b505050506040513d60408110156109ec57600080fd5b5080516020909101516001600160401b0316606086015290505b80610b0c5773__$7a619e2484503bc317a624d2cc621a55c4$__630b2c70098a73__$7a619e2484503bc317a624d2cc621a55c4$__63012984046040518163ffffffff1660e01b815260040160206040518083038186803b158015610a6a57600080fd5b505af4158015610a7e573d6000803e3d6000fd5b505050506040513d6020811015610a9457600080fd5b5051604080516001600160e01b031960e086901b1681526001600160a01b0390931660048401526001600160401b039182166024840152908b166044830152516064808301926000929190829003018186803b158015610af357600080fd5b505af4158015610b07573d6000803e3d6000fd5b505050505b60609093015192945091925050505b935093915050565b6000610b2d6129b8565b600160086001600160401b038716040384166001600160401b0316600014610c595773__$7a619e2484503bc317a624d2cc621a55c4$__630b2c70098773__$7a619e2484503bc317a624d2cc621a55c4$__63d8685e086040518163ffffffff1660e01b815260040160206040518083038186803b158015610bae57600080fd5b505af4158015610bc2573d6000803e3d6000fd5b505050506040513d6020811015610bd857600080fd5b5051604080516001600160e01b031960e086901b1681526001600160a01b0390931660048401526001600160401b0391821660248401529088166044830152516064808301926000929190829003018186803b158015610c3757600080fd5b505af4158015610c4b573d6000803e3d6000fd5b505050506000915050611467565b6000610ca4878673__$6af7953b03ecb3cadd1ca9bb3675b9b8d6$__63b0c41fc56040518163ffffffff1660e01b815260040160206040518083038186803b1580156102f357600080fd5b6001600160401b03166040840152905080610dc45773__$7a619e2484503bc317a624d2cc621a55c4$__630b2c70098873__$7a619e2484503bc317a624d2cc621a55c4$__63a4652fa56040518163ffffffff1660e01b815260040160206040518083038186803b158015610d1857600080fd5b505af4158015610d2c573d6000803e3d6000fd5b505050506040513d6020811015610d4257600080fd5b5051604080516001600160e01b031960e086901b1681526001600160a01b0390931660048401526001600160401b0391821660248401529089166044830152516064808301926000929190829003018186803b158015610da157600080fd5b505af4158015610db5573d6000803e3d6000fd5b50505050600092505050611467565b604080830151815163da19616360e01b81526001600160a01b038a1660048201526001600160401b039091166024820152905173__$ab3fd86e507257b3ab9832a7c6180fb495$__9163da196163916044808301926020929190829003018186803b158015610e3257600080fd5b505af4158015610e46573d6000803e3d6000fd5b505050506040513d6020811015610e5c57600080fd5b50516001600160401b03166020808401829052604080516331fe49e960e01b815260048101939093525173__$ab3fd86e507257b3ab9832a7c6180fb495$__926331fe49e9926024808301939192829003018186803b158015610ebe57600080fd5b505af4158015610ed2573d6000803e3d6000fd5b505050506040513d6020811015610ee857600080fd5b505180610f7a575060208083015160408051631956c73d60e01b81526001600160401b0390921660048301525173__$ab3fd86e507257b3ab9832a7c6180fb495$__92631956c73d9260248082019391829003018186803b158015610f4c57600080fd5b505af4158015610f60573d6000803e3d6000fd5b505050506040513d6020811015610f7657600080fd5b5051155b15610fde5773__$7a619e2484503bc317a624d2cc621a55c4$__630b2c70098873__$7a619e2484503bc317a624d2cc621a55c4$__6348b36c3a6040518163ffffffff1660e01b815260040160206040518083038186803b158015610d1857600080fd5b60208083015160408051632d2cffe160e21b81526001600160401b0390921660048301525173__$ab3fd86e507257b3ab9832a7c6180fb495$__9263b4b3ff849260248082019391829003018186803b15801561103a57600080fd5b505af415801561104e573d6000803e3d6000fd5b505050506040513d602081101561106457600080fd5b5051156110f3576040808301518151637e94ad5f60e11b81526001600160401b0391821660048201528187166024820152908816604482015290516001600160a01b0389169163fd295abe91606480830192600092919082900301818387803b1580156110d057600080fd5b505af11580156110e4573d6000803e3d6000fd5b50505050600192505050611467565b60208083015160408051631fb4b3d360e01b81526001600160401b0390921660048301525173__$ab3fd86e507257b3ab9832a7c6180fb495$__92631fb4b3d39260248082019391829003018186803b15801561114f57600080fd5b505af4158015611163573d6000803e3d6000fd5b505050506040513d602081101561117957600080fd5b5051156112af5773__$96c0387300a4d16af366df01fc33f52e50$__6391b78523886111ac8560015b6020020151612513565b878a6040518563ffffffff1660e01b815260040180856001600160a01b03168152602001846001600160401b03168152602001836001600160401b03168152602001826001600160401b0316815260200194505050505060206040518083038186803b15801561121b57600080fd5b505af415801561122f573d6000803e3d6000fd5b505050506040513d602081101561124557600080fd5b50516112aa5773__$7a619e2484503bc317a624d2cc621a55c4$__630b2c70098873__$7a619e2484503bc317a624d2cc621a55c4$__6348b36c3a6040518163ffffffff1660e01b815260040160206040518083038186803b158015610d1857600080fd5b611460565b6020808301516040805163aa7332a960e01b81526001600160401b0390921660048301525173__$ab3fd86e507257b3ab9832a7c6180fb495$__9263aa7332a99260248082019391829003018186803b15801561130b57600080fd5b505af415801561131f573d6000803e3d6000fd5b505050506040513d602081101561133557600080fd5b5051156114605773__$3c056aa8a31fb3ce78f242f7ef99e26695$__6362cba9aa886113628560016111a2565b878a6040518563ffffffff1660e01b815260040180856001600160a01b03168152602001846001600160401b03168152602001836001600160401b03168152602001826001600160401b0316815260200194505050505060206040518083038186803b1580156113d157600080fd5b505af41580156113e5573d6000803e3d6000fd5b505050506040513d60208110156113fb57600080fd5b50516114605773__$7a619e2484503bc317a624d2cc621a55c4$__630b2c70098873__$7a619e2484503bc317a624d2cc621a55c4$__6348b36c3a6040518163ffffffff1660e01b815260040160206040518083038186803b158015610d1857600080fd5b6001925050505b949350505050565b60008061147a6129b8565b6114826129b8565b866001600160a01b031663f7ac913d6040518163ffffffff1660e01b8152600401602060405180830381600087803b1580156114bd57600080fd5b505af11580156114d1573d6000803e3d6000fd5b505050506040513d60208110156114e757600080fd5b50516001600160401b0316816000602002018181525050866001600160a01b031663fa644af573__$edd6a44efa4a8bdf57aa57ccba2bcfbb1d$__6342db36676040518163ffffffff1660e01b815260040160206040518083038186803b15801561155157600080fd5b505af4158015611565573d6000803e3d6000fd5b505050506040513d602081101561157b57600080fd5b5051604080516001600160e01b031960e085901b1681526001600160401b0390921660048301525160248083019260209291908290030181600087803b1580156115c457600080fd5b505af11580156115d8573d6000803e3d6000fd5b505050506040513d60208110156115ee57600080fd5b50516001600160401b03166040808401919091528051638c295e3560e01b8152905173__$6af7953b03ecb3cadd1ca9bb3675b9b8d6$__91638c295e35916004808301926020929190829003018186803b15801561164b57600080fd5b505af415801561165f573d6000803e3d6000fd5b505050506040513d602081101561167557600080fd5b50516040830151166001600160401b03161580159061170c575073__$6af7953b03ecb3cadd1ca9bb3675b9b8d6$__63bc8957436040518163ffffffff1660e01b815260040160206040518083038186803b1580156116d357600080fd5b505af41580156116e7573d6000803e3d6000fd5b505050506040513d60208110156116fd57600080fd5b50516001600160401b03168514155b1561181c5773__$6af7953b03ecb3cadd1ca9bb3675b9b8d6$__63a16de11c6040518163ffffffff1660e01b815260040160206040518083038186803b15801561175557600080fd5b505af4158015611769573d6000803e3d6000fd5b505050506040513d602081101561177f57600080fd5b5051604080516373a3563960e11b815290516001600160401b039092169173__$6af7953b03ecb3cadd1ca9bb3675b9b8d6$__9163e746ac72916004808301926020929190829003018186803b1580156117d857600080fd5b505af41580156117ec573d6000803e3d6000fd5b505050506040513d602081101561180257600080fd5b50516040840151166001600160401b0390811690911c1681525b73__$6af7953b03ecb3cadd1ca9bb3675b9b8d6$__63cf7ecf796040518163ffffffff1660e01b815260040160206040518083038186803b15801561186057600080fd5b505af4158015611874573d6000803e3d6000fd5b505050506040513d602081101561188a57600080fd5b505181516001600160401b0390911614156118ad57600186935093505050610b1b565b866001600160a01b031663fa644af573__$edd6a44efa4a8bdf57aa57ccba2bcfbb1d$__63443fd5986040518163ffffffff1660e01b815260040160206040518083038186803b15801561190057600080fd5b505af4158015611914573d6000803e3d6000fd5b505050506040513d602081101561192a57600080fd5b5051604080516001600160e01b031960e085901b1681526001600160401b0390921660048301525160248083019260209291908290030181600087803b15801561197357600080fd5b505af1158015611987573d6000803e3d6000fd5b505050506040513d602081101561199d57600080fd5b50516001600160401b0381166060840152603c1c600f16602082018190526119cd57600186935093505050610b1b565b6020810151600813806119e4575060208101516009125b156119f757600080935093505050610b1b565b6000600882600160200201510360030190508060090273__$6af7953b03ecb3cadd1ca9bb3675b9b8d6$__63a1a290056040518163ffffffff1660e01b815260040160206040518083038186803b158015611a5157600080fd5b505af4158015611a65573d6000803e3d6000fd5b505050506040513d6020811015611a7b57600080fd5b505160408051635a72a4dd60e11b815290516001600160401b03909216929092019173__$6af7953b03ecb3cadd1ca9bb3675b9b8d6$__9163b4e549ba91600480820192602092909190829003018186803b158015611ad957600080fd5b505af4158015611aed573d6000803e3d6000fd5b505050506040513d6020811015611b0357600080fd5b50516001600160401b039081169190910360408401819052600789810b9190921681811b830b901d90910b14611b425760008094509450505050610b1b565b602c82600560200201818152505073__$6af7953b03ecb3cadd1ca9bb3675b9b8d6$__63a1a290056040518163ffffffff1660e01b815260040160206040518083038186803b158015611b9457600080fd5b505af4158015611ba8573d6000803e3d6000fd5b505050506040513d6020811015611bbe57600080fd5b505160a083015160608086015160001960016001600160401b039485161b011682169282169290921b16602085015260039083015260096080808401919091526101ff9084015260005b81811215612502578082036000190183600460200201510273__$6af7953b03ecb3cadd1ca9bb3675b9b8d6$__63a1a290056040518163ffffffff1660e01b815260040160206040518083038186803b158015611c6457600080fd5b505af4158015611c78573d6000803e3d6000fd5b505050506040513d6020811015611c8e57600080fd5b50516001600160401b039081169190910160408501819052608086015160608601516020880180518d861690941c9092168085169185169190911b9092019092169182905290600090611ce2908c90612520565b6001600160401b031660a0880152905080611d095760008097509750505050505050610b1b565b73__$6af7953b03ecb3cadd1ca9bb3675b9b8d6$__63574a20ef6040518163ffffffff1660e01b815260040160206040518083038186803b158015611d4d57600080fd5b505af4158015611d61573d6000803e3d6000fd5b505050506040513d6020811015611d7757600080fd5b505160a0870151166001600160401b0316611d9e5760008097509750505050505050610b1b565b600073__$6af7953b03ecb3cadd1ca9bb3675b9b8d6$__63a1a290056040518163ffffffff1660e01b815260040160206040518083038186803b158015611de457600080fd5b505af4158015611df8573d6000803e3d6000fd5b505050506040513d6020811015611e0e57600080fd5b505160a0880151600a81901c663fffffffffffff166001600160401b039092169190911b915060011c60071680156124e9578060021480611e4f5750806006145b15611e6857600080995099505050505050505050610b1b565b73__$6af7953b03ecb3cadd1ca9bb3675b9b8d6$__63026797d96040518163ffffffff1660e01b815260040160206040518083038186803b158015611eac57600080fd5b505af4158015611ec0573d6000803e3d6000fd5b505050506040513d6020811015611ed657600080fd5b505187516001600160401b0390911614156120125773__$6af7953b03ecb3cadd1ca9bb3675b9b8d6$__63a4521d8b6040518163ffffffff1660e01b815260040160206040518083038186803b158015611f2f57600080fd5b505af4158015611f43573d6000803e3d6000fd5b505050506040513d6020811015611f5957600080fd5b505160a0890151166001600160401b031615801590611ff4575073__$6af7953b03ecb3cadd1ca9bb3675b9b8d6$__638a17ca866040518163ffffffff1660e01b815260040160206040518083038186803b158015611fb757600080fd5b505af4158015611fcb573d6000803e3d6000fd5b505050506040513d6020811015611fe157600080fd5b50516040890151166001600160401b0316155b1561200d57600080995099505050505050505050610b1b565b6120a9565b73__$6af7953b03ecb3cadd1ca9bb3675b9b8d6$__63a4521d8b6040518163ffffffff1660e01b815260040160206040518083038186803b15801561205657600080fd5b505af415801561206a573d6000803e3d6000fd5b505050506040513d602081101561208057600080fd5b505160a0890151166001600160401b03166120a957600080995099505050505050505050610b1b565b73__$6af7953b03ecb3cadd1ca9bb3675b9b8d6$__634e95a4106040518163ffffffff1660e01b815260040160206040518083038186803b1580156120ed57600080fd5b505af4158015612101573d6000803e3d6000fd5b505050506040513d602081101561211757600080fd5b50516040890151166001600160401b03161561213457600281901d175b6001818c1d1661215257600080995099505050505050505050610b1b565b604087015160001960016001600160401b039283161b018082168a528316161561218a57600080995099505050505050505050610b1b565b600073__$6af7953b03ecb3cadd1ca9bb3675b9b8d6$__63501bec456040518163ffffffff1660e01b815260040160206040518083038186803b1580156121d057600080fd5b505af41580156121e4573d6000803e3d6000fd5b505050506040513d60208110156121fa57600080fd5b505160a08a0151166001600160401b03161580612315575073__$6af7953b03ecb3cadd1ca9bb3675b9b8d6$__633fe2098a6040518163ffffffff1660e01b815260040160206040518083038186803b15801561225657600080fd5b505af415801561226a573d6000803e3d6000fd5b505050506040513d602081101561228057600080fd5b505160a08a0151166001600160401b0316158015612315575073__$6af7953b03ecb3cadd1ca9bb3675b9b8d6$__63b0c41fc56040518163ffffffff1660e01b815260040160206040518083038186803b1580156122dd57600080fd5b505af41580156122f1573d6000803e3d6000fd5b505050506040513d602081101561230757600080fd5b50516001600160401b03168c145b905073__$6af7953b03ecb3cadd1ca9bb3675b9b8d6$__63501bec456040518163ffffffff1660e01b815260040160206040518083038186803b15801561235b57600080fd5b505af415801561236f573d6000803e3d6000fd5b505050506040513d602081101561238557600080fd5b505160a08a0180519091176001600160401b031690526040805163b0c41fc560e01b8152905173__$6af7953b03ecb3cadd1ca9bb3675b9b8d6$__9163b0c41fc5916004808301926020929190829003018186803b1580156123e657600080fd5b505af41580156123fa573d6000803e3d6000fd5b505050506040513d602081101561241057600080fd5b50516001600160401b03168c14156124a75773__$6af7953b03ecb3cadd1ca9bb3675b9b8d6$__633fe2098a6040518163ffffffff1660e01b815260040160206040518083038186803b15801561246657600080fd5b505af415801561247a573d6000803e3d6000fd5b505050506040513d602081101561249057600080fd5b505160a08a0180519091176001600160401b031690525b80156124c8576124c68e8a600160200201518b60056020020151612776565b505b50509551600198508019909616958a16959095179550610b1b945050505050565b506001600160401b031660208701525050600101611c08565b506000988998509650505050505050565b67fffffffffffff0001690565b600080600073__$ab3fd86e507257b3ab9832a7c6180fb495$__63da19616386866040518363ffffffff1660e01b815260040180836001600160a01b03168152602001826001600160401b031681526020019250505060206040518083038186803b15801561258e57600080fd5b505af41580156125a2573d6000803e3d6000fd5b505050506040513d60208110156125b857600080fd5b505160408051632d2cffe160e21b81526001600160401b0383166004820152905191925073__$ab3fd86e507257b3ab9832a7c6180fb495$__9163b4b3ff8491602480820192602092909190829003018186803b15801561261857600080fd5b505af415801561262c573d6000803e3d6000fd5b505050506040513d602081101561264257600080fd5b505115806126d1575073__$ab3fd86e507257b3ab9832a7c6180fb495$__631d2f5b5b826040518263ffffffff1660e01b815260040180826001600160401b0316815260200191505060206040518083038186803b1580156126a357600080fd5b505af41580156126b7573d6000803e3d6000fd5b505050506040513d60208110156126cd57600080fd5b5051155b156126e357600080925092505061276f565b6001856001600160a01b03166350cec2d586604080518363ffffffff1660e01b815260040180836001600160401b0316815260200182815260200192505050602060405180830381600087803b15801561273c57600080fd5b505af1158015612750573d6000803e3d6000fd5b505050506040513d602081101561276657600080fd5b50519093509150505b9250929050565b60008073__$ab3fd86e507257b3ab9832a7c6180fb495$__63da19616386866040518363ffffffff1660e01b815260040180836001600160a01b03168152602001826001600160401b031681526020019250505060206040518083038186803b1580156127e257600080fd5b505af41580156127f6573d6000803e3d6000fd5b505050506040513d602081101561280c57600080fd5b505160408051632d2cffe160e21b81526001600160401b0383166004820152905191925073__$ab3fd86e507257b3ab9832a7c6180fb495$__9163b4b3ff8491602480820192602092909190829003018186803b15801561286c57600080fd5b505af4158015612880573d6000803e3d6000fd5b505050506040513d602081101561289657600080fd5b50511580612925575073__$ab3fd86e507257b3ab9832a7c6180fb495$__631956c73d826040518263ffffffff1660e01b815260040180826001600160401b0316815260200191505060206040518083038186803b1580156128f757600080fd5b505af415801561290b573d6000803e3d6000fd5b505050506040513d602081101561292157600080fd5b5051155b156129345760009150506129b1565b60408051637e94ad5f60e11b81526001600160401b038087166004830152851660248201526044810182905290516001600160a01b0387169163fd295abe91606480830192600092919082900301818387803b15801561299357600080fd5b505af11580156129a7573d6000803e3d6000fd5b5050505060019150505b9392505050565b6040518060c00160405280600690602082028036833750919291505056fea2646970667358221220726e3caab2cc2283ea73db95d9d97c11de0fa9ddee63f282d9a5585d2143093564736f6c63430007040033",
  "libraries": {
    "RiscVDecoder": "0xFc6E2ceCe819DDcc94423cA469F3F49dfbeefA64",
    "RiscVConstants": "0x08367820CD9849A6FA6964c7cEf53C5C47fA5C08",
    "ShadowAddresses": "0x4D7479bF76387f35D84B9f1BE586Aa83d9118294",
    "PMA": "0x2EaeBb94FFA7FF7d08CF33c46681D3831e04a184",
    "CLINT": "0xBaDC34c0fc1233b68a4a486C227C495f82Be5eB6",
    "HTIF": "0xfdFF3De6C36305319d756455843963080f38cb42",
    "Exceptions": "0xA404230965BB7E08F29732B3A38F001d6C28e0E2"
  },
  "devdoc": {
    "author": "Felipe Argento",
    "kind": "dev",
    "methods": {
      "readVirtualMemory(MemoryInteractor,uint64,uint64)": {
        "params": {
          "vaddr": "is the words virtual address",
          "wordSize": "can be uint8, uint16, uint32 or uint64"
        },
        "returns": {
          "_0": "True if write was succesfull, false if not.",
          "_1": "Word with receiveing value."
        }
      },
      "writeVirtualMemory(MemoryInteractor,uint64,uint64,uint64)": {
        "params": {
          "vaddr": "is the words virtual address",
          "val": "is the value to be written",
          "wordSize": "can be uint8, uint16, uint32 or uint64"
        },
        "returns": {
          "_0": "True if write was succesfull, false if not."
        }
      }
    },
    "title": "Virtual Memory",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "readVirtualMemory(MemoryInteractor,uint64,uint64)": {
        "notice": "Read word to virtual memory"
      },
      "writeVirtualMemory(MemoryInteractor,uint64,uint64,uint64)": {
        "notice": "Writes word to virtual memory"
      }
    },
    "notice": "Defines Virtual Memory behaviour",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}